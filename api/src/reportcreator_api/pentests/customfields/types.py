import dataclasses
import enum
import functools
import json
from pathlib import Path
from frozendict import frozendict
from datetime import date
from inspect import isclass
from types import GenericAlias
from typing import Any, Optional, Union
from django.utils.deconstruct import deconstructible
from reportcreator_api.utils.decorators import freeze_args
from reportcreator_api.utils.utils import is_date_string


@enum.unique
class FieldDataType(enum.Enum):
    STRING = 'string'
    MARKDOWN = 'markdown'
    CVSS = 'cvss'
    CWE = 'cwe'
    DATE = 'date'
    NUMBER = 'number'
    BOOLEAN = 'boolean'
    ENUM = 'enum'
    COMBOBOX = 'combobox'
    USER = 'user'
    OBJECT = 'object'
    LIST = 'list'


@enum.unique
class FieldOrigin(enum.Enum):
    CORE = 'core'
    PREDEFINED = 'predefined'
    CUSTOM = 'custom'


@enum.unique
class CvssVersion(enum.Enum):
    CVSS40 = 'CVSS:4.0'
    CVSS31 = 'CVSS:3.1'
    ANY = None


@deconstructible
@dataclasses.dataclass
class FieldDefinition:
    type: FieldDataType = None
    label: str = ''
    origin: FieldOrigin = FieldOrigin.CUSTOM
    extra_info: dict[str, Any] = dataclasses.field(default_factory=dict)


@deconstructible
@dataclasses.dataclass
class BaseStringField(FieldDefinition):
    default: Optional[str] = None
    required: bool = True


@deconstructible
@dataclasses.dataclass
class StringField(BaseStringField):
    spellcheck: bool = False
    pattern: Optional[str] = None
    type: FieldDataType = FieldDataType.STRING


@deconstructible
@dataclasses.dataclass
class MarkdownField(BaseStringField):
    type: FieldDataType = FieldDataType.MARKDOWN


@deconstructible
@dataclasses.dataclass
class CvssField(BaseStringField):
    type: FieldDataType = FieldDataType.CVSS
    cvss_version: CvssVersion = CvssVersion.ANY


@deconstructible
@dataclasses.dataclass
class ComboboxField(BaseStringField):
    type: FieldDataType = FieldDataType.COMBOBOX
    suggestions: list[str] = dataclasses.field(default_factory=list)


@deconstructible
@dataclasses.dataclass
class DateField(FieldDefinition):
    default: Optional[str] = None
    required: bool = True
    type: FieldDataType = FieldDataType.DATE

    def __post_init__(self):
        if self.default and not is_date_string(self.default):
            raise ValueError('Default value is not a date', self.default)


@deconstructible
@dataclasses.dataclass
class EnumChoice:
    value: str
    label: str = None

    def __post_init__(self):
        self.label = self.value if not self.label else self.label


@deconstructible
@dataclasses.dataclass
class EnumField(FieldDefinition):
    choices: list[EnumChoice] = dataclasses.field(default_factory=list)
    default: Optional[str] = None
    required: bool = True
    type: FieldDataType = FieldDataType.ENUM

    def __post_init__(self):
        if self.default and self.default not in {c.value for c in self.choices}:
            raise ValueError(
                'Default value is not a valid enum choice', self.default)


@deconstructible
@dataclasses.dataclass
class CweField(BaseStringField):
    type: FieldDataType = FieldDataType.CWE

    @staticmethod
    @functools.cache
    def cwe_definitions() -> list[dict]:
        return json.loads(Path(__file__).parent / 'cwe.json')

    @staticmethod
    def is_valid_cwe(cwe):
        return cwe is None or \
            cwe in set(map(lambda c: f"CWE-{c['id']}", CweField.cwe_defintions()))
        
    def __post_init__(self):
        if not CweField.is_valid_cwe(self.default):
            raise ValueError('Default value is not a valid CWE')


@deconstructible
@dataclasses.dataclass
class NumberField(FieldDefinition):
    default: Optional[Union[float, int]] = None
    required: bool = True
    type: FieldDataType = FieldDataType.NUMBER


@deconstructible
@dataclasses.dataclass
class BooleanField(FieldDefinition):
    default: Optional[bool] = None
    type: FieldDataType = FieldDataType.BOOLEAN


@deconstructible
@dataclasses.dataclass
class UserField(FieldDefinition):
    required: bool = True
    type: FieldDataType = FieldDataType.USER


@deconstructible
@dataclasses.dataclass
class ObjectField(FieldDefinition):
    properties: dict[str, FieldDefinition] = dataclasses.field(
        default_factory=dict)
    type: FieldDataType = FieldDataType.OBJECT


@deconstructible
@dataclasses.dataclass
class ListField(FieldDefinition):
    items: FieldDefinition = None
    required: bool = True
    type: FieldDataType = FieldDataType.LIST


_FIELD_DATA_TYPE_CLASSES_MAPPING = {
    FieldDataType.STRING: StringField,
    FieldDataType.MARKDOWN: MarkdownField,
    FieldDataType.CVSS: CvssField,
    FieldDataType.CWE: CweField,
    FieldDataType.DATE: DateField,
    FieldDataType.NUMBER: NumberField,
    FieldDataType.BOOLEAN: BooleanField,
    FieldDataType.ENUM: EnumField,
    FieldDataType.COMBOBOX: ComboboxField,
    FieldDataType.USER: UserField,
    FieldDataType.OBJECT: ObjectField,
    FieldDataType.LIST: ListField,
}


def _field_from_dict(t: type, v: Union[dict, str, Any]) -> FieldDefinition:
    if isinstance(t, GenericAlias):
        if t.__origin__ is list and isinstance(v, (list, tuple)):
            return [_field_from_dict(t.__args__[0], e) for e in v]
        elif t.__origin__ is dict and isinstance(v, (dict, frozendict)):
            return {_field_from_dict(t.__args__[0], k): _field_from_dict(t.__args__[1], e) for k, e in v.items()}
    elif isinstance(v, t):
        return v
    elif isclass(t) and issubclass(t, enum.Enum):
        return t(v)
    elif isinstance(t, date) and isinstance(v, str):
        return date.fromisoformat(v)
    elif dataclasses.is_dataclass(t) and isinstance(v, (dict, frozendict)):
        field_types = {f.name: f.type for f in dataclasses.fields(t)}
        dataclass_args = {f: _field_from_dict(
            field_types[f], v[f]) for f in field_types if f in v}
        try:
            return t(**dataclass_args)
        except TypeError:
            pass

    raise ValueError('Could not decode field definition', v)


def _parse_field_definition_entry(definition: dict) -> FieldDefinition:
    if 'type' not in definition:
        raise ValueError('Field type missing')

    type = FieldDataType(definition['type'])
    type_class = _FIELD_DATA_TYPE_CLASSES_MAPPING[type]
    val = _field_from_dict(type_class, definition)
    if type == FieldDataType.OBJECT:
        val.properties = parse_field_definition(
            definition.get('properties', {}))
    elif type == FieldDataType.LIST:
        val.items = _parse_field_definition_entry(definition.get('items', {}))

    return val


@freeze_args
@functools.lru_cache()
def parse_field_definition(definition: dict) -> dict[str, FieldDefinition]:
    out = {}
    for k, d in definition.items():
        out[k] = _parse_field_definition_entry(d)
    return out


def field_definition_to_dict(definition: Union[dict[str, FieldDefinition], Any], extra_info=False):
    if isinstance(definition, (dict, frozendict)):
        return {k: field_definition_to_dict(v, extra_info=extra_info) for k, v in definition.items()}
    elif isinstance(definition, (list, tuple)):
        return [field_definition_to_dict(e, extra_info=extra_info) for e in definition]
    elif dataclasses.is_dataclass(definition):
        d = dataclasses.asdict(definition)
        d_extra_info = d.pop('extra_info', {})
        if extra_info:
            d |= d_extra_info
        return field_definition_to_dict(d, extra_info=extra_info)
    elif isinstance(definition, enum.Enum):
        return definition.value
    elif isinstance(definition, date):
        return date.isoformat()
    else:
        return definition


# TODO: CWE field
# * [x] add customfields type
#   * [x] definition: string "CWE-XXX"
#   * [x] serializer
#   * [x] validation
#   * [x] ensure_defined_structure
#   * [x] sort by CWE
#   * [x] format_template_field => dict of whole CWE defintion + value="CWE-XXX"
# * [ ] frontend
#   * [ ] DynamicInputField
#   * [ ] CWE field/dialog: 
#       * [ ] preview "CWE-XXX - name"
#       * [ ] tree view
#       * [ ] search for name, ID
#       * [ ] lazy fetch CWE list from API
#   * [ ] Input field defintion in design
#   * [x] sort by CWE
# * [ ] API: /api/v1/utils/cwes
# * [ ] tests:
#   * [x] add field_cwe to mock data
#   * [ ] test_custom_fields: 
#       * [ ] validation, data, format, etc.
#       * [ ] default value: invalid CWE => fail
#       * [ ] data invalid CWE => fail
#       * [ ] data invalid CWE number e.g. CWE-999999999 => fail
#   * [ ] test_rendering: CWE field: id, value, name, description
