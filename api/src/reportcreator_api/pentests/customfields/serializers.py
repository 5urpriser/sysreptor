import datetime
from uuid import UUID

from drf_spectacular.types import OpenApiTypes
from drf_spectacular.utils import extend_schema_field
from rest_framework import serializers

from reportcreator_api.pentests.customfields.types import (
    BaseField,
    CweField,
    FieldDataType,
    FieldDefinition,
    ObjectField,
)
from reportcreator_api.users.models import PentestUser


@extend_schema_field(OpenApiTypes.OBJECT)
class DynamicObjectSerializer(serializers.Serializer):
    def __init__(self, *args, **kwargs):
        self._declared_fields = kwargs.pop('fields', {})
        super().__init__(*args, **kwargs)


class DateFieldSerializer(serializers.DateField):
    def to_internal_value(self, value):
        date = super().to_internal_value(value)
        if isinstance(date, datetime.date):
            return date.isoformat()
        else:
            return date


class CweFieldSerializer(serializers.CharField):
    def to_internal_value(self, data):
        out = super().to_internal_value(data)
        if not CweField.is_valid_cwe(out):
            raise serializers.ValidationError('Not a valid CWE')
        return out


class UserField(serializers.PrimaryKeyRelatedField):
    queryset = PentestUser.objects.all()

    def to_internal_value(self, data):
        if isinstance(data, (str, UUID)) and (project := self.context.get('project')):
            if project.members and (user := next(filter(lambda u: str(data) == str(u.id), project.members), None)):
                return str(user.id)
            elif project.imported_members and (imported_user := next(filter(lambda u: data == u.get('id'), project.imported_members), None)):
                return imported_user.get('id')

        user = super().to_internal_value(data)
        return str(user.id) if isinstance(user, PentestUser) else user

    def to_representation(self, value):
        if isinstance(value, (str, UUID)):
            return value
        return super().to_representation(value)


def serializer_from_definition(definition: FieldDefinition|ObjectField, **kwargs):
    return DynamicObjectSerializer(
        fields=dict(filter(lambda t: t[1] is not None, map(lambda t: (t.id, serializer_from_field(t)), definition.fields))),
        **kwargs)


def serializer_from_field(definition: BaseField):
    field_kwargs = {
        'label': definition.label,
        'required': False,
    }
    value_field_kwargs = field_kwargs | {
        'allow_null': True,
        # 'default': getattr(definition, 'default', None),
    }
    field_type = definition.type
    if field_type in [FieldDataType.STRING, FieldDataType.MARKDOWN, FieldDataType.CVSS, FieldDataType.COMBOBOX]:
        return serializers.CharField(trim_whitespace=False, allow_blank=True, **value_field_kwargs)
    elif field_type == FieldDataType.DATE:
        return DateFieldSerializer(**value_field_kwargs)
    elif field_type == FieldDataType.NUMBER:
        return serializers.FloatField(**value_field_kwargs)
    elif field_type == FieldDataType.BOOLEAN:
        return serializers.BooleanField(**value_field_kwargs)
    elif field_type == FieldDataType.ENUM:
        return serializers.ChoiceField(choices=[c.value for c in definition.choices], **value_field_kwargs)
    elif field_type == FieldDataType.CWE:
        return CweFieldSerializer(**value_field_kwargs)
    elif field_type == FieldDataType.USER:
        return UserField(**value_field_kwargs)
    elif field_type == FieldDataType.OBJECT:
        return serializer_from_definition(definition, **field_kwargs)
    elif field_type == FieldDataType.LIST:
        return serializers.ListField(child=serializer_from_field(definition.items), allow_empty=True, **field_kwargs)
    else:
        raise ValueError(f'Encountered unsupported type in field definition: "{field_type}"')
