from datetime import datetime
import enum
from django.conf import settings
from django.db import DatabaseError, models, transaction, IntegrityError
from django.contrib.contenttypes.models import ContentType
from django.utils import timezone
from django.utils.translation import gettext_lazy as _

from reportcreator_api.utils.models import BaseModel
from reportcreator_api.users.models import PentestUser
from reportcreator_api.utils.relations import GenericOneToOneForeignKey, GenericOneToOneRelation


class LockStatus(enum.Enum):
    CREATED = 'created'
    REFRESHED = 'refreshed'
    FAILED = 'failed'


class LockInfo(BaseModel):
    # Generic foreign key to arbitrary/multiple models
    content_type = models.ForeignKey(to=ContentType, on_delete=models.CASCADE)
    object_id = models.UUIDField()
    locked_object = GenericOneToOneForeignKey(ct_field='content_type', fk_field='object_id')

    last_ping = models.DateTimeField(default=timezone.now)
    user = models.ForeignKey(to=PentestUser, on_delete=models.CASCADE, null=False)

    class Meta:
        unique_together = [('content_type', 'object_id')]

    @property
    def expires(self) -> datetime:
        return (self.last_ping or timezone.now()) + settings.MAX_LOCK_TIME

    def refresh_lock(self):
        try:
            self.last_ping = timezone.now()
            self.save(force_update=True)
            return LockStatus.REFRESHED
        except (self.DoesNotExist, DatabaseError):
            return LockStatus.FAILED


class LockableMixin(models.Model):
    lock_info_data = GenericOneToOneRelation(to=LockInfo)

    class Meta:
        abstract = True

    @property
    def lock_info(self):
        if not self.is_locked:
            return None
        return self.lock_info_data

    @property
    def is_locked(self):
        return self.lock_info_data is not None and timezone.now() <= self.lock_info_data.expires

    def _cleanup_old_lock(self):
        if self.lock_info_data:
            self.lock_info_data.delete()
            self.lock_info_data = None

    def lock(self, user, refresh_lock=True):
        if self.is_locked and self.lock_info.user != user:
            # Already locked by another user
            return LockStatus.FAILED
        elif self.is_locked and self.lock_info.user == user:
            # Refresh lock such that it does not expire
            if refresh_lock:
                return self.lock_info.refresh_lock()
            else:
                return LockStatus.REFRESHED
        elif not self.is_locked:
            with transaction.atomic():
                self._cleanup_old_lock()
                try:
                    self.lock_info_data = LockInfo.objects.create(locked_object=self, user=user)
                    return LockStatus.CREATED
                except IntegrityError:
                    self.lock_info_data = LockInfo.objects.get(content_type=ContentType.objects.get_for_model(self), object_id=self.id)
                    if self.lock_info_data.user == user:
                        return LockStatus.REFRESHED
                    else:
                        return LockStatus.FAILED
        return LockStatus.FAILED

    def unlock(self, user):
        if not self.is_locked:
            self._cleanup_old_lock()
            return True
        elif self.is_locked and self.lock_info.user == user:
            self._cleanup_old_lock()
            return True
        else:
            return False


class SourceEnum(models.TextChoices):
    CREATED = 'created', 'Created'
    IMPORTED = 'imported', 'Imported'
    IMPORTED_DEPENDENCY = 'imported_dependency', 'Imported Dependency'
    CUSTOMIZED = 'customized', 'Customized'
    SNAPSHOT = 'snapshot', 'Snapshot'


class ImportableMixin(models.Model):
    source = models.CharField(max_length=50, choices=SourceEnum.choices, default=SourceEnum.CREATED, db_index=True, editable=False)

    class Meta:
        abstract = True


class ReviewStatus(models.TextChoices):
    IN_PROGRESS = 'in-progress', _('In progress')
    READY_FOR_REVIEW = 'ready-for-review', _('Ready for review')
    NEEDS_IMPROVEMENT = 'needs-improvement', _('Needs improvement')
    FINISHED = 'finished', _('Finished')


class Language(models.TextChoices):
    ENGLISH_US = 'en-US', True, 'English (en-US)'
    ENGLISH_GB = 'en-GB', True, 'English (en-GB)'
    ENGLISH_AU = 'en-AU', True, 'English (en-AU)'
    ENGLISH_CA = 'en-CA', True, 'English (en-CA)'
    ENGLISH_NZ = 'en-NZ', True, 'English (en-NZ)'
    ENGLISH_ZA = 'en-ZA', True, 'English (en-ZA)'
    GERMAN_DE = 'de-DE', True, 'German (de-DE)'
    GERMAN_AT = 'de-AT', True, 'German (de-AT)'
    GERMAN_CH = 'de-CH', True, 'German (de-CH)'
    SPANISH = 'es-ES', True, 'Spanish (es-ES)'
    FRENCH_FR = 'fr-FR', True, 'French (fr-FR)'
    FRENCH_CA = 'fr-CA', True, 'French (fr-CA)'
    FRENCH_BE = 'fr-BE', True, 'French (fr-BE)'
    FRENCH_CH = 'fr-CH', True, 'French (fr-CH)'
    PORTUGUESE_PT = 'pt-PT', True, 'Portuguese (pt-PT)'
    PORTUGUESE_BR = 'pt-BR', True, 'Portuguese (pt-BR)'
    ITALIAN = 'it-IT', True, 'Italian (it-IT)'
    DUTCH = 'nl-NL', True, 'Dutch (nl-NL)'
    DANISH = 'da-DK', True, 'Danish (da-DK)'
    POLISH = 'pl-PL', True, 'Polish (pl-PL)'
    UKRAINIAN = 'uk-UA', True, 'Ukrainian (uk-UA)'
    # RUSSIAN = 'ru-RU', True, 'Russian (ru-RU)'
    ROMANIAN = 'ro-RO', True, 'Romanian (ro-RO)'
    SLOVAK = 'sk-SK', True, 'Slovak (sk-SK)'
    SLOVENIAN = 'sl-SI', True, 'Slovenian (sl-SI)'
    GREEK = 'el-GR', True, 'Greek (el-GR)'
    SWEDISH = 'sv-SE', True, 'Swedish (sv-SE)'

    # Languages without LanguageTool support
    ALBANIAN = 'sq-AL', False, 'Albanian (sq-AL)'
    BULGARIAN = 'bg-BG', False, 'Bulgarian (bg-BG)'
    CROATIAN = 'hr-HR', False, 'Croatian (hr-HR)'
    ESTONIAN = 'et-EE', False, 'Estonian (et-EE)'
    FINNISH = 'fi-FI', False, 'Finnish (fi-FI)'
    HUNGARIAN = 'hu-HU', False, 'Hungarian (hu-HU)'
    LATVIAN = 'lv-LV', False, 'Latvian (lv-LV)'
    LITHUANIAN = 'lt-LT', False, 'Lithuanian (lt-LT)'
    MALTESE = 'mt-MT', False, 'Maltese (mt-MT)'
    NORWEGIAN = 'nb-NO', False, 'Norwegian (nb-NO)'
    SERBIAN = 'sr-SP', False, 'Serbian (sr-SP)'
    TURKISH = 'tr-TR', False, 'Turkish (tr-TR)'

    def __new__(cls, value, spellcheck):
        obj = str.__new__(cls, value)
        obj._value_ = value
        obj.spellcheck = spellcheck
        return obj


def get_default_language():
    if settings.PREFERRED_LANGUAGES:
        return Language(settings.PREFERRED_LANGUAGES[0])
    return Language.ENGLISH_US


class LanguageMixin(models.Model):
    language = models.CharField(choices=Language.choices, default=get_default_language, max_length=5, db_index=True)

    class Meta:
        abstract = True

