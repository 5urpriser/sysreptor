import functools
import itertools
import operator
from uuid import uuid4
from jsonschema import ValidationError
from django.db import models
from django.contrib.postgres.fields import ArrayField
from django.core.serializers.json import DjangoJSONEncoder
from django.utils.translation import gettext_lazy as _

from reportcreator_api.archive.crypto.fields import EncryptedField
from reportcreator_api.pentests.customfields.mixins import EncryptedCustomFieldsMixin
from reportcreator_api.pentests.customfields.predefined_fields import FINDING_FIELDS_CORE, FINDING_FIELDS_PREDEFINED, \
    REPORT_FIELDS_CORE, REPORT_FIELDS_PREDEFINED, finding_field_order_default, finding_fields_default, report_fields_default, \
    finding_ordering_default, report_sections_default
from reportcreator_api.pentests.customfields.types import FieldDataType, FieldDefinition, field_definition_to_dict, parse_field_definition
from reportcreator_api.pentests.customfields.utils import HandleUndefinedFieldsOptions, ensure_defined_structure, set_field_origin
from reportcreator_api.pentests.customfields.validators import FieldDefinitionValidator, FindingOrderingValidator, SectionDefinitionValidator
from reportcreator_api.pentests.models.common import ImportableMixin, Language, LanguageMixin, LockableMixin, ReviewStatus
from reportcreator_api.users.models import PentestUser
from reportcreator_api.utils.decorators import cache
from reportcreator_api.utils.error_messages import ErrorMessage
from reportcreator_api.utils.models import BaseModel, HistoricalRecords
from reportcreator_api.pentests import querysets
from reportcreator_api.utils.utils import remove_duplicates


class ProjectTypeScope(models.TextChoices):
    GLOBAL = 'global', _('Global')
    PRIVATE = 'private', _('Private')
    PROJECT = 'project', _('Project')


class ProjectType(LockableMixin, LanguageMixin, ImportableMixin, BaseModel):
    name = models.CharField(max_length=255, null=False, blank=False, db_index=True)

    # PDF Template
    report_template = EncryptedField(base_field=models.TextField(default=''))
    report_styles = EncryptedField(base_field=models.TextField(default=''))
    report_preview_data = EncryptedField(base_field=models.JSONField(encoder=DjangoJSONEncoder, default=dict))

    # Report
    report_fields = models.JSONField(
        encoder=DjangoJSONEncoder, 
        validators=[FieldDefinitionValidator(core_fields=REPORT_FIELDS_CORE, predefined_fields=REPORT_FIELDS_PREDEFINED)], 
        default=report_fields_default)
    report_sections = models.JSONField(encoder=DjangoJSONEncoder, validators=[SectionDefinitionValidator()], default=report_sections_default)

    # Findings
    finding_fields = models.JSONField(
        encoder=DjangoJSONEncoder, 
        validators=[FieldDefinitionValidator(core_fields=FINDING_FIELDS_CORE, predefined_fields=FINDING_FIELDS_PREDEFINED)], 
        default=finding_fields_default)
    finding_field_order = models.JSONField(encoder=DjangoJSONEncoder, default=finding_field_order_default)
    finding_ordering = models.JSONField(encoder=DjangoJSONEncoder, validators=[FindingOrderingValidator()], default=finding_ordering_default)

    linked_project = models.ForeignKey(to='PentestProject', on_delete=models.SET_NULL, null=True, blank=True)
    linked_user = models.ForeignKey(to=PentestUser, on_delete=models.CASCADE, null=True, blank=True)

    copy_of = models.ForeignKey(to='ProjectType', on_delete=models.SET_NULL, null=True)

    history = HistoricalRecords(cascade_delete_history=True)
    objects = querysets.ProjectTypeManager()

    class Meta:
        constraints = [
            models.CheckConstraint(
                name='linked_project_or_user',
                check=models.Q(linked_project=None) | models.Q(linked_user=None)
            ),
        ]

    @property
    def finding_fields_obj(self) -> dict[str, FieldDefinition]:
        return parse_field_definition(self.finding_fields)

    @property
    def report_fields_obj(self) -> dict[str, FieldDefinition]:
        return parse_field_definition(self.report_fields)
    
    @property
    def scope(self) -> ProjectTypeScope:
        if self.linked_project_id:
            return ProjectTypeScope.PROJECT
        elif self.linked_user_id:
            return ProjectTypeScope.PRIVATE
        elif not self.linked_project_id and not self.linked_user_id:
            return ProjectTypeScope.GLOBAL

    def __str__(self) -> str:
        return self.name

    def clean(self) -> None:
        # Validate report sections contain only defined fields
        if undefined_fields := set(itertools.chain(*map(lambda s: s['fields'], self.report_sections))) - set(self.report_fields.keys()):
            raise ValidationError(_('Unknown fields in section: %(fields)s') % {'fields': list(undefined_fields)})

        # Validate finding field field order contains only defined fields
        if undefined_fields := set(self.finding_field_order) - set(self.finding_fields.keys()):
            raise ValidationError(_('Unknown fields in finding order: %(fields)s') % {'fields': list(undefined_fields)})
        
        # Validate finding ordering contains only defined fields supported types
        unsupported_fields = []
        for o in self.finding_ordering:
            d = self.finding_fields_obj.get(o['field'])
            if not d or d.type in [FieldDataType.LIST, FieldDataType.OBJECT, FieldDataType.USER]:
                unsupported_fields.append(o['field'])
        if unsupported_fields:
            raise ValidationError(_('Unsupported fields in finding ordering: %(fields)s') % {'fields': list(unsupported_fields)})

    def save(self, *args, **kwargs):
        # Ensure static fields are marked correctly
        self.report_fields = field_definition_to_dict(set_field_origin(self.report_fields_obj, predefined_fields=REPORT_FIELDS_CORE | REPORT_FIELDS_PREDEFINED))
        self.finding_fields = field_definition_to_dict(set_field_origin(self.finding_fields_obj, predefined_fields=FINDING_FIELDS_CORE | FINDING_FIELDS_PREDEFINED))

        # Ensure report section definition contains all fields
        section_fields = set()
        for s in self.report_sections:
            s['fields'] = remove_duplicates(s['fields'])
            section_fields |= set(s['fields'])
        report_fields = set(self.report_fields.keys())
        if missing_fields := list(report_fields - section_fields):
            others_section = [s for s in self.report_sections if s['id'] == 'other']
            if others_section:
                others_section = others_section[0]
            else:
                others_section = {
                    'id': 'other',
                    'label': 'Other',
                    'fields': [],
                }
                self.report_sections.append(others_section)
            others_section['fields'].extend(missing_fields)
        # Remove unknown fields from section definition
        for section in self.report_sections:
            for unknown_field in set(section['fields']) - report_fields:
                section['fields'].remove(unknown_field)
        
        # Ensure finding order contains all fields
        finding_fields = set(self.finding_fields.keys())
        self.finding_field_order = remove_duplicates(self.finding_field_order + list(finding_fields))
        # Remove unknown fields from finding_field_order
        for unknown_field in set(self.finding_field_order) - finding_fields:
            self.finding_field_order.remove(unknown_field)

        # Remove unknown fields from finding_ordering
        for ordering_def in list(self.finding_ordering):
            d = self.finding_fields_obj.get(ordering_def['field'])
            if not d or d.type in [FieldDataType.LIST, FieldDataType.OBJECT, FieldDataType.USER]:
                self.finding_ordering.remove(ordering_def)

        # Ensure correct structure of report_preview_data
        if set(self.changed_fields).intersection({'report_preview_data', 'report_fields', 'finding_fields'}):
            report_data = self.report_preview_data.get('report')
            if not isinstance(report_data, dict):
                report_data = {}

            self.report_preview_data['report'] = report_data | ensure_defined_structure(
                value=report_data, 
                definition=self.report_fields_obj, 
                handle_undefined=HandleUndefinedFieldsOptions.FILL_DEMO_DATA)
            findings = self.report_preview_data.get('findings')
            if not isinstance(findings, list):
                # Generate findings with demo data
                # Static values for core fields
                findings = [
                    {'title': 'First Demo Finding', 'cvss': 'CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:L'}, 
                    {'title': 'Second Demo Finding', 'cvss': 'CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:L'},
                ]
            self.report_preview_data['findings'] = [
                {'id': str(uuid4())} | f | ensure_defined_structure(
                    value=f, 
                    definition=self.finding_fields_obj, 
                    handle_undefined=HandleUndefinedFieldsOptions.FILL_DEMO_DATA)
                for f in findings if isinstance(f, dict)
            ]
        
        return super().save(*args, **kwargs)

    def copy(self, **kwargs):
        return ProjectType.objects.copy(self, **kwargs)


class PentestProject(LanguageMixin, ImportableMixin, BaseModel):
    name = models.CharField(max_length=255, null=False, blank=False, db_index=True)
    tags = ArrayField(base_field=models.CharField(max_length=255), default=list, blank=True, db_index=True)
    project_type = models.ForeignKey(to='ProjectType', on_delete=models.PROTECT)
    imported_members = ArrayField(base_field=models.JSONField(encoder=DjangoJSONEncoder), default=list, blank=True)

    unknown_custom_fields = EncryptedField(base_field=models.JSONField(encoder=DjangoJSONEncoder, default=dict, blank=True, null=True), null=True, blank=True)
    override_finding_order = models.BooleanField(default=False)

    readonly = models.BooleanField(default=False, db_index=True)
    readonly_since = models.DateTimeField(null=True, db_index=True, editable=False)
    
    copy_of = models.ForeignKey(to='PentestProject', on_delete=models.SET_NULL, null=True)

    history = HistoricalRecords(cascade_delete_history=True)
    objects = querysets.PentestProjectManager()

    @property
    def field_definition(self) -> dict[str, FieldDefinition]:
        return self.project_type.report_fields_obj
    
    @property
    def data(self):
        return functools.reduce(operator.or_, map(lambda s: s.data, self.sections.all()), {})
    
    @property
    def data_all(self) -> dict:
        return (self.unknown_custom_fields or {}) | functools.reduce(operator.or_, map(lambda s: s.data_all, self.sections.all()), {})
    
    def __str__(self) -> str:
        return self.name

    def delete(self, using=None, keep_parents=False):
        linked_project_types_to_delete = list(ProjectType.objects \
            .filter(linked_project=self) \
            .annotate(used_by_other=models.Count('pentestproject', filter=~models.Q(pentestproject=models.F('linked_project')))) \
            .filter(used_by_other=0) \
            .values_list('id', flat=True))
        out = super().delete(using=using, keep_parents=keep_parents)
        ProjectType.objects.filter(id__in=linked_project_types_to_delete).delete()
        return out

    def copy(self, **kwargs):
        return PentestProject.objects.copy(self, **kwargs)

    def perform_checks(self) -> list[ErrorMessage]:
        from reportcreator_api.pentests.checks import run_checks
        return list(run_checks(self))


class ProjectMemberRole(BaseModel):
    role = models.CharField(max_length=50, unique=True)
    default = models.BooleanField(default=False)

    @classmethod
    @property
    @cache('ProjectMemberRole.predefined_roles', timeout=10)
    def predefined_roles(cls):
        return ProjectMemberRole.objects.all()

    @classmethod
    @property
    def default_roles(cls) -> list[str]:
        return [r.role for r in cls.predefined_roles if r.default]


class ProjectMemberInfo(BaseModel):
    project = models.ForeignKey(to=PentestProject, on_delete=models.CASCADE, related_name='members')
    user = models.ForeignKey(to=PentestUser, on_delete=models.PROTECT)

    roles = ArrayField(base_field=models.CharField(max_length=50, null=False, blank=False), default=list, blank=True)

    history = HistoricalRecords()

    class Meta:
        unique_together = [('project', 'user')]


class ReportSection(EncryptedCustomFieldsMixin, LockableMixin, BaseModel):
    project = models.ForeignKey(to=PentestProject, on_delete=models.CASCADE, null=False, related_name='sections')
    section_id = models.CharField(max_length=255, null=False, db_index=True, editable=False)

    assignee = models.ForeignKey(to=PentestUser, on_delete=models.SET_NULL, null=True, blank=True)
    status = models.CharField(max_length=20, choices=ReviewStatus.choices, default=ReviewStatus.IN_PROGRESS, db_index=True)

    history = HistoricalRecords()
    objects = models.Manager.from_queryset(querysets.ReportSectionQueryset)()

    class Meta(BaseModel.Meta):
        unique_together = [('project', 'section_id')]

    @property
    def project_type(self) -> ProjectType:
        return self.project.project_type

    @property
    def section_definition(self) -> dict:
        return next(filter(lambda s: s.get('id') == self.section_id, self.project_type.report_sections), {})

    @property
    def section_label(self) -> str:
        return self.section_definition.get('label') or ''
    
    @property
    def section_fields(self) -> list:
        return self.section_definition.get('fields', [])

    @property
    def field_definition(self) -> dict[str, FieldDefinition]:
        return {f: self.project_type.report_fields_obj.get(f) for f in self.section_fields}
    
    @property
    def language(self) -> Language:
        return self.project.language


class PentestFinding(EncryptedCustomFieldsMixin, LockableMixin, BaseModel):
    finding_id = models.UUIDField(default=uuid4, db_index=True, editable=False)
    project = models.ForeignKey(to=PentestProject, on_delete=models.CASCADE, null=False, related_name='findings')

    template_id = EncryptedField(base_field=models.UUIDField(null=True, blank=True), null=True, blank=True)
    assignee = models.ForeignKey(to=PentestUser, on_delete=models.SET_NULL, null=True, blank=True)
    status = models.CharField(max_length=20, choices=ReviewStatus.choices, default=ReviewStatus.IN_PROGRESS, db_index=True)
    order = models.PositiveIntegerField(default=0, db_index=True)

    history = HistoricalRecords()
    objects = querysets.PentestFindingManager()

    class Meta(BaseModel.Meta):
        unique_together = [('project', 'finding_id')]

    @property
    def field_definition(self) -> dict[str, FieldDefinition]:
        return self.project.project_type.finding_fields_obj

    @property
    def language(self) -> Language:
        return self.project.language

    @property
    def title(self) -> str:
        return self.data.get('title')

    def __str__(self) -> str:
        return self.title


# TODO: version history
# * [x] history config
#   * [x] install django-simple-history
#   * [x] history settings
#   * [x] only for professional license
#   * [x] customize history base model: add field prevent_cleanup
# * [x] model
#   * [x] add history fields
#   * [x] add history relations => automatically done by simple_history when ForeignKeys exist
# * [x] migrations
#   * [x] create initial history entry from current state with change_reason="Initial"
#   * [x] file models: initial history from created+uploaded_by
#   * [x] update migrations
# * [x] on delete
#   * [x] project, template, design: delete history
#   * [x] sub-resources: add history entry
# * [ ] scheduled task: 
#   * [ ] clear old history entries
#       * of time-based update history savepoints: FindingTemplateTranslation, findings, sections, notes, ProjectType?
#   * [ ] keep history entries for 
#       * history records with history_prevent_cleanup
#       * history_type in ["+", "-"]
#       * first/last history entry
#       * when history_user changed (keep last entry before changing user) (this might change when introducing websockets?)
#       * last history of user (with websockets) in cleanup timeframe
#       * unfrequently changing models: images/files, ProjectMemberInfo, FindingTemplate?
# * [x] misc
#   * [x] history savepoint descriptions: set via signal
#   * [x] delete history files from storage
# * [ ] review usages of bulk_create (and bulk_update) and replace with bulk_create_with_history
#   * [x] custom bulk_{create,update}_with_history
#       * [x] only if license.is_professional()
#       * [x] skip update if no changes (diff with previous version)
#   * [ ] set change_reason
#   * [x] bulk_create: import/export project/design/template
#   * [x] bulk_create: copy project/design
#   * [x] bulk_create: create finding from template
#   * [x] bulk_create: create template from finding
#   * [x] bulk_create + bulk_update: ProjectMemberInfo
#   * [x] bulk_create + bulk_update: FindingTemplateTranslation
#   * [ ] bulk_create + bulk_update: in project_project_type_changed_postsave
#   * [ ] bulk_create: project_type_field_definition_changed
# * [ ] API
#   * [ ] allow viewing deleted resource if query_date==history_date (but not if query_date > history_date) ???
#   * [x] django querysets do not support filter() after union(): prevents cursor pagination for history timeline
#   * [x] project history
#   * [x] finding history
#   * [x] section history
#   * [x] template history
#       * [x] old template + translations
#       * [x] old image
#       * [x] translation history timeline: optional with template + translation created/deleted
# * [ ] frontend
#   * [x] history timeline item styling
#   * [x] template history
#       * [x] separate history per translation
#       * [x] in main translations: translation history + created/deleted translations entries + main_translation changed
#       * [x] whole template+translations at timestamp
#       * [x] history sidebar
#   * [x] project history
#   * [x] finding history
#   * [x] section history
#   * [x] note history
#   * [ ] design history
# * [x] file handling
#   * [x] cleanup: on file delete signal => also check history models before deleting file from storage
#   * [x] encrypt/decrypt command
#   * [x] cleanup files command
#   * [x] backup files
# * [x] admin
#   * [x] view history
# * [ ] docs
#   * [ ] add history to feature list
#   * [ ] explain history in a docs page (in menu reporting -> change history)
# * [ ] tests
#   * [ ] test_api
#   * [ ] test_history: 
#       * [ ] test snapshot trigger points
#       * [ ] test request user assigned and current date
#       * [ ] test delete project: all history deleted incl. files
#       * [ ] test no history created for community license
#       * [ ] history timeline API
#       * [ ] test history API time in future (of after last savepoint): return current state
#       * [ ] test history API time == delete time: object returned; time > delete time: not returned
#   * [ ] test_backup: 
#       * [ ] history models included in backup
#       * [ ] deleted file from history (file only in history, not in main model) included in backup
#
# * [ ] update to django-simple-history 3.4.0 when it gets released to pypi: https://github.com/jazzband/help/issues/344
# * [ ] update NOTICE file
# * [ ] code cleanup:
#   * [ ] prefer history_context over instance._history assignment
#   * [ ] resolve TODOs
#   * [ ] fix OpenAPI spec warnings
