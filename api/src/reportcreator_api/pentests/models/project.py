import functools
import itertools
import operator
from typing import Optional
from uuid import uuid4

from django.contrib.postgres.fields import ArrayField
from django.core.serializers.json import DjangoJSONEncoder
from django.db import models
from django.utils.translation import gettext_lazy as _
from jsonschema import ValidationError

from reportcreator_api.archive.crypto.fields import EncryptedField
from reportcreator_api.pentests import querysets
from reportcreator_api.pentests.customfields.mixins import EncryptedCustomFieldsMixin
from reportcreator_api.pentests.customfields.predefined_fields import (
    FINDING_FIELDS_CORE,
    FINDING_FIELDS_PREDEFINED,
    REPORT_FIELDS_CORE,
    REPORT_FIELDS_PREDEFINED,
    finding_field_order_default,
    finding_fields_default,
    finding_ordering_default,
    report_fields_default,
    report_sections_default,
)
from reportcreator_api.pentests.customfields.types import (
    FieldDataType,
    FieldDefinition,
    field_definition_to_dict,
    parse_field_definition,
)
from reportcreator_api.pentests.customfields.utils import (
    HandleUndefinedFieldsOptions,
    ensure_defined_structure,
    iterate_fields,
    set_field_origin,
    set_value_at_path,
)
from reportcreator_api.pentests.customfields.validators import (
    DefaultNotesValidator,
    FieldDefinitionValidator,
    FindingOrderingValidator,
    SectionDefinitionValidator,
)
from reportcreator_api.pentests.models.common import (
    ImportableMixin,
    Language,
    LanguageMixin,
    LockableMixin,
    ReviewStatus,
)
from reportcreator_api.users.models import PentestUser
from reportcreator_api.utils.decorators import cache
from reportcreator_api.utils.error_messages import ErrorMessage
from reportcreator_api.utils.history import HistoricalRecords
from reportcreator_api.utils.models import BaseModel
from reportcreator_api.utils.utils import remove_duplicates


class ProjectTypeScope(models.TextChoices):
    GLOBAL = 'global', _('Global')
    PRIVATE = 'private', _('Private')
    PROJECT = 'project', _('Project')


class ProjectTypeStatus(models.TextChoices):
    IN_PROGRESS = 'in-progress', _('In progress')
    READY_FOR_REVIEW = 'ready-for-review', _('Ready for review')
    NEEDS_IMPROVEMENT = 'needs-improvement', _('Needs improvement')
    FINISHED = 'finished', _('Finished')
    DEPRECATED = 'deprecated', _('Deprecated')


class ProjectType(LockableMixin, LanguageMixin, ImportableMixin, BaseModel):
    name = models.CharField(max_length=255, null=False, blank=False, db_index=True)
    status = models.CharField(max_length=20, choices=ProjectTypeStatus.choices, default=ProjectTypeStatus.IN_PROGRESS, db_index=True)
    tags = ArrayField(
            base_field=models.CharField(max_length=255),
            default=list, blank=True, db_index=True)

    # PDF Template
    report_template = EncryptedField(base_field=models.TextField(default=''))
    report_styles = EncryptedField(base_field=models.TextField(default=''))
    report_preview_data = EncryptedField(base_field=models.JSONField(encoder=DjangoJSONEncoder, default=dict))

    # Report
    report_fields = models.JSONField(
        encoder=DjangoJSONEncoder,
        validators=[FieldDefinitionValidator(core_fields=REPORT_FIELDS_CORE, predefined_fields=REPORT_FIELDS_PREDEFINED)],
        default=report_fields_default)
    report_sections = models.JSONField(encoder=DjangoJSONEncoder, validators=[SectionDefinitionValidator()], default=report_sections_default)

    # Findings
    finding_fields = models.JSONField(
        encoder=DjangoJSONEncoder,
        validators=[FieldDefinitionValidator(core_fields=FINDING_FIELDS_CORE, predefined_fields=FINDING_FIELDS_PREDEFINED)],
        default=finding_fields_default)
    finding_field_order = models.JSONField(encoder=DjangoJSONEncoder, default=finding_field_order_default)
    finding_ordering = models.JSONField(encoder=DjangoJSONEncoder, validators=[FindingOrderingValidator()], default=finding_ordering_default)

    # Notes
    default_notes = ArrayField(
        base_field=models.JSONField(encoder=DjangoJSONEncoder, null=False, blank=False),
        validators=[DefaultNotesValidator()], default=list, blank=True)

    linked_project = models.ForeignKey(to='PentestProject', on_delete=models.SET_NULL, null=True, blank=True)
    linked_user = models.ForeignKey(to=PentestUser, on_delete=models.CASCADE, null=True, blank=True)

    copy_of = models.ForeignKey(to='ProjectType', on_delete=models.SET_NULL, null=True, blank=True)

    history = HistoricalRecords(cascade_delete_history=True)
    objects = querysets.ProjectTypeManager()

    class Meta:
        constraints = [
            models.CheckConstraint(
                name='linked_project_or_user',
                check=models.Q(linked_project=None) | models.Q(linked_user=None),
            ),
        ]

    @property
    def finding_fields_obj(self) -> dict[str, FieldDefinition]:
        return parse_field_definition(self.finding_fields)

    @property
    def report_fields_obj(self) -> dict[str, FieldDefinition]:
        return parse_field_definition(self.report_fields)

    @property
    def scope(self) -> ProjectTypeScope:
        if self.linked_project_id:
            return ProjectTypeScope.PROJECT
        elif self.linked_user_id:
            return ProjectTypeScope.PRIVATE
        elif not self.linked_project_id and not self.linked_user_id:
            return ProjectTypeScope.GLOBAL

    def __str__(self) -> str:
        return self.name

    def is_file_referenced(self, f) -> bool:
        # Always assume a file is referenced, because the reference might be dynamically generated via template language
        return True

    def clean(self) -> None:
        # Validate report sections contain only defined fields
        if undefined_fields := set(itertools.chain(*map(lambda s: s['fields'], self.report_sections))) - set(self.report_fields.keys()):
            raise ValidationError(_('Unknown fields in section: %(fields)s') % {'fields': list(undefined_fields)})

        # Validate finding field field order contains only defined fields
        if undefined_fields := set(self.finding_field_order) - set(self.finding_fields.keys()):
            raise ValidationError(_('Unknown fields in finding order: %(fields)s') % {'fields': list(undefined_fields)})

        # Validate finding ordering contains only defined fields supported types
        unsupported_fields = []
        for o in self.finding_ordering:
            d = self.finding_fields_obj.get(o['field'])
            if not d or d.type in [FieldDataType.LIST, FieldDataType.OBJECT, FieldDataType.USER]:
                unsupported_fields.append(o['field'])
        if unsupported_fields:
            raise ValidationError(_('Unsupported fields in finding ordering: %(fields)s') % {'fields': list(unsupported_fields)})

    def save(self, *args, **kwargs):
        # Ensure static fields are marked correctly
        self.report_fields = field_definition_to_dict(set_field_origin(self.report_fields_obj, predefined_fields=REPORT_FIELDS_CORE | REPORT_FIELDS_PREDEFINED))
        self.finding_fields = field_definition_to_dict(set_field_origin(self.finding_fields_obj, predefined_fields=FINDING_FIELDS_CORE | FINDING_FIELDS_PREDEFINED))

        # Ensure report section definition contains all fields
        section_fields = set()
        for s in self.report_sections:
            s['fields'] = remove_duplicates(s['fields'])
            section_fields |= set(s['fields'])
        report_fields = set(self.report_fields.keys())
        if missing_fields := list(report_fields - section_fields):
            others_section = [s for s in self.report_sections if s['id'] == 'other']
            if others_section:
                others_section = others_section[0]
            else:
                others_section = {
                    'id': 'other',
                    'label': 'Other',
                    'fields': [],
                }
                self.report_sections.append(others_section)
            others_section['fields'].extend(missing_fields)
        # Remove unknown fields from section definition
        for section in self.report_sections:
            for unknown_field in set(section['fields']) - report_fields:
                section['fields'].remove(unknown_field)

        # Ensure finding order contains all fields
        finding_fields = set(self.finding_fields.keys())
        self.finding_field_order = remove_duplicates(self.finding_field_order + list(finding_fields))
        # Remove unknown fields from finding_field_order
        for unknown_field in set(self.finding_field_order) - finding_fields:
            self.finding_field_order.remove(unknown_field)

        # Remove unknown fields from finding_ordering
        for ordering_def in list(self.finding_ordering):
            d = self.finding_fields_obj.get(ordering_def['field'])
            if not d or d.type in [FieldDataType.LIST, FieldDataType.OBJECT, FieldDataType.USER]:
                self.finding_ordering.remove(ordering_def)

        # Ensure correct structure of report_preview_data
        if set(self.changed_fields).intersection({'report_preview_data', 'report_fields', 'finding_fields'}):
            def update_preview_data_defaults(new_data, old_data, new_definition, old_definition):
                new_values = {t[0]: t for t in iterate_fields(new_data, new_definition)}
                old_values = {t[0]: t for t in iterate_fields(old_data, old_definition)}
                for path, (_, new_value, new_definition) in new_values.items():
                    if path not in old_values:
                        continue
                    _, old_value, old_definition = old_values[path]
                    if new_definition.type in [FieldDataType.MARKDOWN, FieldDataType.STRING] and \
                        old_definition.type == new_definition.type and \
                        old_value == old_definition.default and \
                        old_value == new_value:
                        set_value_at_path(new_data, path, new_definition.default)

            report_data = self.report_preview_data.get('report')
            if not isinstance(report_data, dict):
                report_data = {}

            # Update preview data fields containing old default values to new default values
            self.report_preview_data['report'] = report_data | ensure_defined_structure(
                value=report_data,
                definition=self.report_fields_obj,
                handle_undefined=HandleUndefinedFieldsOptions.FILL_DEMO_DATA)
            if 'report_fields' in self.changed_fields:
                update_preview_data_defaults(
                    new_data=self.report_preview_data['report'],
                    old_data=report_data,
                    new_definition=self.report_fields_obj,
                    old_definition=parse_field_definition(self.initial['report_fields']),
                )

            findings_data = self.report_preview_data.get('findings')
            if not isinstance(findings_data, list) or not all(map(lambda f: isinstance(f, dict), findings_data)):
                # Generate findings with demo data
                # Static values for core fields
                findings_data = [
                    {'title': 'First Demo Finding', 'cvss': 'CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:L'},
                    {'title': 'Second Demo Finding', 'cvss': 'CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:L/A:L'},
                ]
            self.report_preview_data['findings'] = [
                {'id': str(uuid4())} | f | ensure_defined_structure(
                    value=f,
                    definition=self.finding_fields_obj,
                    handle_undefined=HandleUndefinedFieldsOptions.FILL_DEMO_DATA)
                for f in findings_data if isinstance(f, dict)
            ]
            # Update preview data fields containing old default values to new default values
            if 'finding_fields' in self.changed_fields:
                for new_finding in self.report_preview_data['findings']:
                    old_finding = next(filter(lambda f: f.get('id') == new_finding.get('id'), findings_data), None)
                    if not old_finding:
                        continue
                    update_preview_data_defaults(
                        new_data=new_finding,
                        old_data=old_finding,
                        new_definition=self.finding_fields_obj,
                        old_definition=parse_field_definition(self.initial['finding_fields']),
                    )

        return super().save(*args, **kwargs)

    def copy(self, **kwargs):
        return ProjectType.objects.copy(self, **kwargs)


class PentestProject(LanguageMixin, ImportableMixin, BaseModel):
    name = models.CharField(max_length=255, null=False, blank=False, db_index=True)
    tags = ArrayField(base_field=models.CharField(max_length=255), default=list, blank=True, db_index=True)
    project_type = models.ForeignKey(to='ProjectType', on_delete=models.PROTECT)
    imported_members = ArrayField(base_field=models.JSONField(encoder=DjangoJSONEncoder), default=list, blank=True)

    unknown_custom_fields = EncryptedField(base_field=models.JSONField(encoder=DjangoJSONEncoder, default=dict, blank=True, null=True), null=True, blank=True)
    override_finding_order = models.BooleanField(default=False)

    readonly = models.BooleanField(default=False, db_index=True)
    readonly_since = models.DateTimeField(null=True, db_index=True, editable=False)

    copy_of = models.ForeignKey(to='PentestProject', on_delete=models.SET_NULL, null=True)

    history = HistoricalRecords(cascade_delete_history=True)
    objects = querysets.PentestProjectManager()

    @property
    def field_definition(self) -> dict[str, FieldDefinition]:
        return self.project_type.report_fields_obj

    @property
    def data(self):
        return functools.reduce(operator.or_, map(lambda s: s.data, self.sections.all()), {})

    @property
    def data_all(self) -> dict:
        return (self.unknown_custom_fields or {}) | functools.reduce(operator.or_, map(lambda s: s.data_all, self.sections.all()), {})

    def __str__(self) -> str:
        return self.name

    def delete(self, using=None, keep_parents=False):
        linked_project_types_to_delete = list(ProjectType.objects \
            .filter(linked_project=self) \
            .annotate(used_by_other=models.Count('pentestproject', filter=~models.Q(pentestproject=models.F('linked_project')))) \
            .filter(used_by_other=0) \
            .values_list('id', flat=True))
        out = super().delete(using=using, keep_parents=keep_parents)
        ProjectType.objects.filter(id__in=linked_project_types_to_delete).delete()
        return out

    def copy(self, **kwargs):
        return PentestProject.objects.copy(self, **kwargs)

    def perform_checks(self) -> list[ErrorMessage]:
        from reportcreator_api.pentests.checks import run_checks
        return list(run_checks(self))

    def is_file_referenced(self, f, sections=True, findings=True, notes=True) -> bool:
        # Project data (sections)
        if sections:
            if f.name in str(self.data_all):
                return True

        # Findings
        if findings:
            for finding in self.findings.all():
                if f.name in str(finding.data_all):
                    return True

        # Notes
        if notes:
            for note in self.notes.all():
                if note.is_file_referenced(f):
                    return True
        return False


class ProjectMemberRole(BaseModel):
    role = models.CharField(max_length=50, unique=True)
    default = models.BooleanField(default=False)

    @classmethod
    @property
    @cache('ProjectMemberRole.predefined_roles', timeout=10)
    def predefined_roles(cls):
        return ProjectMemberRole.objects.all()

    @classmethod
    @property
    def default_roles(cls) -> list[str]:
        return [r.role for r in cls.predefined_roles if r.default]


class ProjectMemberInfo(BaseModel):
    project = models.ForeignKey(to=PentestProject, on_delete=models.CASCADE, related_name='members')
    user = models.ForeignKey(to=PentestUser, on_delete=models.PROTECT)

    roles = ArrayField(base_field=models.CharField(max_length=50, null=False, blank=False), default=list, blank=True)

    history = HistoricalRecords()

    class Meta:
        unique_together = [('project', 'user')]


class ReportSection(EncryptedCustomFieldsMixin, BaseModel):
    project = models.ForeignKey(to=PentestProject, on_delete=models.CASCADE, null=False, related_name='sections')
    section_id = models.CharField(max_length=255, null=False, db_index=True, editable=False)

    assignee = models.ForeignKey(to=PentestUser, on_delete=models.SET_NULL, null=True, blank=True)
    status = models.CharField(max_length=20, choices=ReviewStatus.choices, default=ReviewStatus.IN_PROGRESS, db_index=True)

    history = HistoricalRecords()
    objects = models.Manager.from_queryset(querysets.ReportSectionQueryset)()

    class Meta(BaseModel.Meta):
        unique_together = [('project', 'section_id')]

    @property
    def project_type(self) -> ProjectType:
        return self.project.project_type

    @property
    def section_definition(self) -> dict:
        return next(filter(lambda s: s.get('id') == self.section_id, self.project_type.report_sections), {})

    @property
    def section_label(self) -> str:
        return self.section_definition.get('label') or ''

    @property
    def section_fields(self) -> list:
        return self.section_definition.get('fields', [])

    @property
    def field_definition(self) -> dict[str, FieldDefinition]:
        return {f: self.project_type.report_fields_obj.get(f) for f in self.section_fields}

    @property
    def language(self) -> Language:
        return self.project.language


class PentestFinding(EncryptedCustomFieldsMixin, BaseModel):
    finding_id = models.UUIDField(default=uuid4, db_index=True, editable=False)
    project = models.ForeignKey(to=PentestProject, on_delete=models.CASCADE, null=False, related_name='findings')

    template_id = EncryptedField(base_field=models.UUIDField(null=True, blank=True), null=True, blank=True)
    assignee = models.ForeignKey(to=PentestUser, on_delete=models.SET_NULL, null=True, blank=True)
    status = models.CharField(max_length=20, choices=ReviewStatus.choices, default=ReviewStatus.IN_PROGRESS, db_index=True)
    order = models.PositiveIntegerField(default=0, db_index=True)

    history = HistoricalRecords()
    objects = querysets.PentestFindingManager()

    class Meta(BaseModel.Meta):
        unique_together = [('project', 'finding_id')]

    @property
    def field_definition(self) -> dict[str, FieldDefinition]:
        return self.project.project_type.finding_fields_obj

    @property
    def language(self) -> Language:
        return self.project.language

    @property
    def title(self) -> str:
        return self.data.get('title')

    def __str__(self) -> str:
        return self.title


class CommentStatus(models.TextChoices):
    OPEN = 'open', _('Open')
    RESOLVED = 'resolved', _('Resolved')


class Comment(BaseModel):
    finding = models.ForeignKey(to=PentestFinding, on_delete=models.CASCADE, related_name='comments', null=True, blank=True)
    section = models.ForeignKey(to=ReportSection, on_delete=models.CASCADE, related_name='comments', null=True, blank=True)

    user = models.ForeignKey(to=PentestUser, on_delete=models.SET_NULL, null=True, blank=True)
    status = models.CharField(max_length=20, choices=CommentStatus.choices, default=CommentStatus.OPEN)
    text = EncryptedField(base_field=models.TextField())

    path = models.TextField()
    text_position_from = models.PositiveIntegerField(null=True, blank=True)
    text_position_to = models.PositiveIntegerField(null=True, blank=True)
    text_original = EncryptedField(base_field=models.TextField(null=True, blank=True), null=True, blank=True)

    objects = querysets.CommentManager()

    class Meta(BaseModel.Meta):
        constraints = [
            models.CheckConstraint(
                name='comment_finding_or_section',
                check=(models.Q(finding__isnull=True) & models.Q(section__isnull=False)) | (models.Q(finding__isnull=False) & models.Q(section__isnull=True)),
            ),
        ]

    @property
    def text_position(self) -> Optional[dict]:
        if self.text_position_from is not None and self.text_position_to is not None:
            return {'from': self.text_position_from, 'to': self.text_position_to}
        return None

    @text_position.setter
    def text_position(self, value: Optional[dict]):
        if value:
            if not isinstance(value.get('from'), int) or not isinstance(value.get('to'), int) or value['from'] >= value['to']:
                raise ValueError('Invalid text position')
            self.text_position_from = value['from']
            self.text_position_to = value['to']
        else:
            self.text_position_from = None
            self.text_position_to = None


class CommentAnswer(BaseModel):
    comment = models.ForeignKey(to=Comment, on_delete=models.CASCADE, related_name='answers')
    user = models.ForeignKey(to=PentestUser, on_delete=models.SET_NULL, null=True, blank=True)
    text = EncryptedField(base_field=models.TextField())


# TODO: comments
# * [x] model
#   * [x] comment model
#       * [x] creation time
#       * [x] user
#       * [x] status: open, resolved
#       * [x] comment text
#       * [x] text_position=None or {'from': index, 'to': index, 'original': string}
#       * [x] relations
#   * [x] comment answer
#       * [x] creation time
#       * [x] user
#       * [x] text
#       * [x] comment relation
# * [x] migrations
# * [x] admin
#   * [x] add models to admin
#   * [x] add links to related models
# * [x] API
#   * [x] views: list, get, create, update, delete, resolve
#   * [x] serializers
#   * [x] permissions:
#       * [x] list, get: community+professional license
#       * [x] create, update, delete: professional license
# * [ ] signals
#   * [ ] move comment position on collab.update_text (or set None)
#   * [ ] move comment to other section if field in moved
#   * [ ] delete comment when field is deleted
#   * [ ] handle commented list items moved/deleted (comment on list item and child fields)
# * [ ] websocket
#   * [ ] add to inital message of ReportingConsumer
#   * [ ] move comment position on collab.update_text (or set None)
#   * [ ] collab.comment: create comment, rebase position with version
# * [x] checks
#   * [x] warning for unresolved comments
# * [x] export/import
#   * [x] export/import comments with project
#   * [x] non-existent user-infos (i.e. user does not exist on instance) => set null
# * [ ] frontend
#   * [ ] useReportingCollab
#   * [ ] markdown editor
#       * [ ] show comments in text
#       * [ ] toolbar: add comment button
#   * [ ] pages: finding, section, findingHistory, sectionHistory
#   * [ ] maybe: toggle sidebar with comments
#   * [ ] comment icon besides field/text line
#   * [ ] add comments to non-markdown fields: via comment sidebar?
# * [ ] tests
#   * [x] test backup + restore
#   * [x] test_checks: warning for unresolved comments, no warning for resolved comments
#   * [x] test_api
#   * [x] test_import_export
#   * [x] test_copy
#   * [ ] test_customfields
#       * [ ] field moved to other section: comment moved
#       * [ ] field deleted: comment deleted
#       * [ ] list item deleted: comment deleted
#   * [ ] test_collab
#       * [ ] test insert text before comment: position updated
#       * [ ] test insert text inside comment: position updated
#       * [ ] test delete commented text: position set to None


# TODO: discussion
# * general behavior
#   * comment text range in markdown: current position in text, original text
#   * comment whole field: other field types
#   * status enum: resolve/open comments
#   * comment threads: main comment + answers
#   * who can edit comments: only creator, others can answer
#   * allow everyone to resolve comments
#   * users can add comment for fields in finding.data, fields in section.data
#   * allow multiple comments per field
# * UI:
#   * comment sidebar: like word/google docs
#   * icon besides line/field
#   * out of scope: replacement suggestions
# * export/import comments: yes
#   * change handling of imported users: just save user_id => if not exists: "Unknown"
# * history for comments: no
