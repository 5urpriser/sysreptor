from base64 import b64decode
import functools
import io
import json
from django.conf import settings
from rest_framework import serializers, exceptions
from django.db import transaction
from django.db.models import F, Exists, OuterRef
from django.utils import timezone
from reportcreator_api.archive import crypto
from drf_spectacular.utils import extend_schema_field, OpenApiTypes

from reportcreator_api.archive.crypto import pgp, CryptoError
from reportcreator_api.pentests.customfields.serializers import serializer_from_definition
from reportcreator_api.pentests.customfields.utils import HandleUndefinedFieldsOptions, check_definitions_compatible, ensure_defined_structure
from reportcreator_api.pentests.models import FindingTemplate, LockInfo, NotebookPage, PentestFinding, PentestProject, ProjectType, ProjectTypeScope, \
    ReportSection, SourceEnum, \
    UploadedAsset, UploadedImage, ProjectMemberInfo, ProjectMemberRole, UploadedProjectFile, UploadedUserNotebookImage, UploadedUserNotebookFile, \
    UserPublicKey, ArchivedProject, ArchivedProjectKeyPart, ArchivedProjectPublicKeyEncryptedKeyPart, UploadedTemplateImage
from reportcreator_api.pentests.models.common import Language
from reportcreator_api.pentests.models.template import FindingTemplateTranslation
from reportcreator_api.users.models import PentestUser
from reportcreator_api.users.serializers import PentestUserSerializer, RelatedUserSerializer
from reportcreator_api.utils.error_messages import ErrorMessageSerializer
from reportcreator_api.utils.files import compress_image
from reportcreator_api.utils.utils import omit_items, omit_keys


class LockInfoSerializer(serializers.ModelSerializer):
    user = PentestUserSerializer(read_only=True)

    def __init__(self, *args, **kwargs):
        kwargs['read_only'] = True
        super().__init__(*args, **kwargs)
    
    class Meta:
        model = LockInfo
        fields = [
            'created', 'updated', 'last_ping', 'expires', 'user',
        ]
        read_only_fields = ['last_ping']


class ProjectTypeShortSerializer(serializers.ModelSerializer):
    details = serializers.HyperlinkedIdentityField(view_name='projecttype-detail', read_only=True)
    assets = serializers.HyperlinkedIdentityField(view_name='uploadedasset-list', lookup_url_kwarg='projecttype_pk', read_only=True)  

    class Meta:
        model = ProjectType
        fields = [
            'id', 'created', 'updated', 'source', 'scope',
            'name', 'language',
            'details', 'assets',
        ]


class ProjectTypeDetailSerializer(ProjectTypeShortSerializer):
    lock_info = LockInfoSerializer()
    report_template = serializers.CharField(required=False, allow_blank=True)
    report_styles = serializers.CharField(required=False, allow_blank=True)
    report_preview_data = serializers.DictField(required=False)
    copy_of = serializers.PrimaryKeyRelatedField(read_only=True)

    class Meta(ProjectTypeShortSerializer.Meta):
        fields = ProjectTypeShortSerializer.Meta.fields + [
            'copy_of', 'lock_info',
            'report_template', 'report_styles', 'report_preview_data',
            'report_fields', 'report_sections',
            'finding_fields', 'finding_field_order',
        ]


class ProjectTypeCreateSerializer(ProjectTypeDetailSerializer):
    scope = serializers.ChoiceField(choices=[c for c in ProjectTypeScope.choices if c[0] in [ProjectTypeScope.GLOBAL.value, ProjectTypeScope.PRIVATE.value]])
    
    def validate_scope(self, value):
        if value == ProjectTypeScope.PRIVATE and not settings.ENABLE_PRIVATE_DESIGNS:
            raise serializers.ValidationError(f'Scope "{value}" not supported')
        elif value == ProjectTypeScope.GLOBAL and not (self.context['request'].user.is_admin or self.context['request'].user.is_designer):
            raise exceptions.PermissionDenied()
        return value

    def create(self, validated_data):
        scope = validated_data.pop('scope')
        validated_data |= {
            ProjectTypeScope.GLOBAL: {'linked_project': None, 'linked_user': None},
            ProjectTypeScope.PRIVATE: {'linked_project': None, 'linked_user': self.context['request'].user},
        }[scope]
        return super().create(validated_data)


class ProjectTypePreviewSerializer(serializers.ModelSerializer):
    report_template = serializers.CharField(required=False, allow_blank=True, write_only=True)
    report_styles = serializers.CharField(required=False, allow_blank=True, write_only=True)
    report_preview_data = serializers.DictField(required=False, write_only=True)

    class Meta:
        model = ProjectType
        fields = ['report_template', 'report_styles', 'report_preview_data']


class ProjectTypeRelatedField(serializers.PrimaryKeyRelatedField):
    def get_queryset(self):
        return ProjectType.objects.only_permitted(self.context['request'].user)


class PentestProjectRelatedField(serializers.PrimaryKeyRelatedField):
    def get_queryset(self):
        return PentestProject.objects.only_permitted(self.context['request'].user)


class PentestFindingSerializer(serializers.ModelSerializer):
    id = serializers.UUIDField(source='finding_id', read_only=True)
    project = serializers.PrimaryKeyRelatedField(read_only=True)
    project_type = ProjectTypeRelatedField(source='project.project_type_id', read_only=True)
    lock_info = LockInfoSerializer(read_only=True)
    template = serializers.PrimaryKeyRelatedField(read_only=True, source='template_id')
    assignee = RelatedUserSerializer(required=False, allow_null=True, default=serializers.CreateOnlyDefault(serializers.CurrentUserDefault()))

    class Meta:
        model = PentestFinding
        fields = [
            'id', 'created', 'updated', 'project', 'project_type', 
            'language', 'lock_info', 'template', 'assignee', 'status',
        ]

    def get_fields(self):
        data_field = serializers.DictField()
        if self.context.get('project'):
            data_field = serializer_from_definition(definition=self.context['project'].project_type.finding_fields_obj, **self.get_extra_kwargs().get('data', {}))
        return super().get_fields() | {
            'data': data_field,
        }

    def create(self, validated_data, handle_undefined=HandleUndefinedFieldsOptions.FILL_DEFAULT):
        data = ensure_defined_structure(
            value=validated_data.pop('data', {}), 
            definition=self.context['project'].project_type.finding_fields_obj, 
            handle_undefined=handle_undefined
        )
        instance = PentestFinding(
            project=self.context['project'], 
            **validated_data
        )
        instance.update_data(data)
        instance.save()
        return instance

    def update(self, instance, validated_data):
        instance.update_data(validated_data.pop('data', {}))
        return super().update(instance, validated_data)


class PentestFindingFromTemplateSerializer(PentestFindingSerializer):
    template = serializers.PrimaryKeyRelatedField(queryset=FindingTemplate.objects.select_related('main_translation').all(), required=True, allow_null=False, source='template_id')
    template_language = serializers.ChoiceField(choices=Language.choices, required=False, allow_null=True, write_only=True)

    class Meta(PentestFindingSerializer.Meta):
        fields = PentestFindingSerializer.Meta.fields + ['template_language']
        read_only_fields = ['data', 'assignee', 'status']

    def validate(self, attrs):
        if attrs.get('template_language') and not any(map(lambda tr: tr.language == attrs['template_language'], attrs['template_id'].translations.all())):
            raise serializers.ValidationError('Language does not exist in template')
        return super().validate(attrs)
    
    def update_image_references(self, data, name_old, name_new):
        # Update image references via simple string manipulation
        data_str = json.dumps(data)
        data_str = data_str.replace(f'/images/name/{name_old}', f'/images/name/{name_new}')
        return json.loads(data_str)
    
    def template_images_to_project_images(self, template, data):
        template_images = list(template.images.all())
        new_project_images = []
        if template_images:
            project_image_names = list(self.context['project'].images.values_list('name', flat=True))
            for ti in template_images:
                name = ti.name
                # Detect image name conflicts (same image name exists in project and template)
                if name in project_image_names:
                    while name in project_image_names + [i.name for i in template_images]:
                        name = UploadedTemplateImage.objects.randomize_name(ti.name)
                    # Change image references in template fields
                    data = self.update_image_references(data=data, name_old=ti.name, name_new=name)
                    
                new_project_images.append(UploadedImage(
                    linked_object=self.context['project'], 
                    name=name, 
                    name_hash=UploadedImage.hash_name(name),
                    file=ti.file,
                    uploaded_by=ti.uploaded_by
                ))
        return new_project_images, data

    @transaction.atomic()
    def create(self, validated_data):
        template = validated_data.pop('template_id')
        template_language = validated_data.pop('template_language', None)
        translation = next(filter(lambda tr: tr.language == template_language, template.translations.all()), None) or template.main_translation
        data = translation.get_data(inherit_main=True)

        new_project_images, data = self.template_images_to_project_images(template, data)
        finding = super().create(validated_data | {
            'template_id': template.id,
            'data': data | validated_data.pop('data', {}),
        }, handle_undefined=HandleUndefinedFieldsOptions.FILL_NONE)
        UploadedImage.objects.bulk_create(new_project_images)
        FindingTemplate.objects.filter(id=template.id).increment_usage_count()
        return finding


class ProjectMemberInfoSerializer(serializers.ModelSerializer):
    class Meta:
        model = ProjectMemberInfo
        fields = ['roles']
    
    def __init__(self, user_serializer=PentestUserSerializer, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.user_serializer = user_serializer

    def get_related_user_serializer(self):
        s = RelatedUserSerializer(user_serializer=self.user_serializer)
        s.bind('user', self)
        return s

    def to_representation(self, instance):
        return self.get_related_user_serializer().to_representation(instance.user) | \
            super().to_representation(instance)

    def to_internal_value(self, data):
        return super().to_internal_value(data) | {
            'user': self.get_related_user_serializer().to_internal_value(data)
        }


class ImportedProjectMemberInfoSerializer(serializers.ModelSerializer):
    roles = serializers.ListField(child=serializers.CharField(), allow_empty=True)

    class Meta(PentestUserSerializer.Meta):
        fields = omit_items(PentestUserSerializer.Meta.fields, ['username']) + ['roles']
        extra_kwargs = {
            'id': {'read_only': False},
        }


class ImportedProjectMemberInfoListSerializer(serializers.ListSerializer):
    child = ImportedProjectMemberInfoSerializer()

    def update(self, instance, validated_data):
        updated = []
        for d in validated_data:
            i = next(filter(lambda e: str(e.get('id')) == str(d.get('id')), instance), {})
            updated.append(i | d)
        return updated


class PentestProjectSerializer(serializers.ModelSerializer):
    project_type = ProjectTypeRelatedField()
    force_change_project_type = serializers.BooleanField(required=False, default=False, write_only=True)

    members = ProjectMemberInfoSerializer(many=True, required=False)
    imported_members = ImportedProjectMemberInfoListSerializer(required=False)

    copy_of = serializers.PrimaryKeyRelatedField(read_only=True)

    details = serializers.HyperlinkedIdentityField(view_name='pentestproject-detail', read_only=True)
    findings = serializers.HyperlinkedIdentityField(view_name='finding-list', lookup_url_kwarg='project_pk', read_only=True)
    sections = serializers.HyperlinkedIdentityField(view_name='section-list', lookup_url_kwarg='project_pk', read_only=True)
    notes = serializers.HyperlinkedIdentityField(view_name='projectnotebookpage-list', lookup_url_kwarg='project_pk', read_only=True)
    images = serializers.HyperlinkedIdentityField(view_name='uploadedimage-list', lookup_url_kwarg='project_pk', read_only=True)

    class Meta:
        model = PentestProject
        fields = [
            'id', 'created', 'updated',
            'name', 'project_type', 'force_change_project_type', 'language', 'tags', 'readonly', 'source', 'copy_of',
            'members', 'imported_members',
            'details', 'findings', 'sections', 'notes', 'images',
        ]
        read_only_fields = ['readonly']

    def validate_project_type(self, value):
        if self.instance and self.instance.project_type != value and not self.initial_data.get('force_change_project_type'):
            res_finding = check_definitions_compatible(self.instance.project_type.finding_fields_obj, value.finding_fields_obj, path=('finding_fields',))
            res_report = check_definitions_compatible(self.instance.project_type.report_fields_obj, value.report_fields_obj, path=('report_fields',))
            if not res_finding[0] or not res_report[0]:
                raise serializers.ValidationError(['Designs have incompatible field definitions. Converting might result in data loss.'] + res_report[1] + res_finding[1])
        
        return value

    @transaction.atomic
    def create(self, validated_data):
        project_type = validated_data.pop('project_type').copy(linked_user=None, source=SourceEnum.SNAPSHOT, created=timezone.now())
        validated_data.pop('force_change_project_type')

        members = validated_data.pop('members', [])

        project = super().create(validated_data | {
            'project_type': project_type,
            'language': project_type.language,
            'custom_fields': ensure_defined_structure(
                value={
                    'title': validated_data.get('name', 'Report Title'),
                },
                definition=project_type.report_fields_obj, 
                handle_undefined=HandleUndefinedFieldsOptions.FILL_DEFAULT
            ),
        })

        # add current user as member
        if not any(map(lambda m: m.get('user') == self.context['request'].user, members)):
            members.append({'user': self.context['request'].user, 'roles': ProjectMemberRole.default_roles})
        ProjectMemberInfo.objects.bulk_create([ProjectMemberInfo(**m, project=project) for m in members])

        project_type.linked_project = project
        project_type.save(update_fields=['linked_project'])

        return project
    
    def update(self, instance, validated_data):
        members = validated_data.pop('members', None)
        if (imported_members := validated_data.get('imported_members')) is not None:
            validated_data['imported_members'] = self.fields['imported_members'].update(instance.imported_members, imported_members)
        if (project_type := validated_data.get('project_type')) and instance.project_type != project_type and project_type.linked_project != instance:
            validated_data['project_type'] = project_type.copy(
                linked_project=instance, 
                linked_user=None,
                source=SourceEnum.SNAPSHOT, 
                created=timezone.now())

        instance = super().update(instance, validated_data)
        if members is not None:
            PentestProject.objects.set_members(instance=instance, members=[ProjectMemberInfo(**m) for m in members])
        return instance


class ReportSectionSerializer(serializers.ModelSerializer):
    id = serializers.CharField(source='section_id', read_only=True)
    project = serializers.PrimaryKeyRelatedField(read_only=True)
    project_type = ProjectTypeRelatedField(source='project.project_type_id', read_only=True)
    label = serializers.CharField(source='section_label', read_only=True)
    fields = serializers.ListField(source='section_fields', child=serializers.CharField(), read_only=True)
    lock_info = LockInfoSerializer()
    assignee = RelatedUserSerializer(required=False, allow_null=True)

    class Meta:
        model = ReportSection
        fields = [
            'id', 'label', 'fields', 'project', 'project_type', 
            'language', 'lock_info', 'assignee', 'status',
        ]
    
    def get_fields(self):
        fields = super().get_fields()
        data_field = serializers.DictField()
        if self.instance and isinstance(self.instance, ReportSection):
            data_field = serializer_from_definition(definition=self.instance.field_definition, **self.get_extra_kwargs().get('data', {}))
        return fields | {
            'data': data_field
        }

    def update(self, instance, validated_data):
        instance.update_data(validated_data.pop('data', {}))
        instance.project.save()
        return super().update(instance, validated_data)


class FindingTemplateTranslationShortDataSerializer(serializers.Serializer):
    title = serializers.CharField()


class FindingTemplateTranslationShortSerializer(serializers.ModelSerializer):
    data = FindingTemplateTranslationShortDataSerializer(source='*')

    class Meta:
        model = FindingTemplateTranslation
        fields = [
            'id', 'created', 'updated', 
            'language', 'status', 'is_main',
            'risk_score', 'risk_level', 'data',
        ]


class FindingTemplateTranslationSerializer(FindingTemplateTranslationShortSerializer):
    def get_fields(self):
        return super().get_fields() | {
            'data': serializer_from_definition(definition=FindingTemplate.field_definition),
        }

    def to_representation(self, instance):
        # Skip undefined data fields not present in translation.data, but defined by the serializer
        res = super().to_representation(instance)
        res['data'] = omit_keys(res['data'], set(res['data'].keys()) - set(instance.data.keys()))
        return res
    
    def create(self, validated_data):
        data = validated_data.pop('data')
        instance = FindingTemplateTranslation(template=self.context['template'], **validated_data)
        instance.update_data(data)
        instance.save()
        return instance
    
    def update(self, instance, validated_data):
        instance.update_data(validated_data.pop('data', {}))
        return super().update(instance, validated_data)


class FindingTemplateTranslationCreateMainSerializer(FindingTemplateTranslationSerializer):
    is_main = serializers.BooleanField(default=False)

    class Meta(FindingTemplateTranslationSerializer.Meta):
        extra_kwargs = {'id': {'read_only': False, 'required': False, 'allow_null': True}}


class FindingTemplateShortSerializer(serializers.ModelSerializer):
    translations = FindingTemplateTranslationShortSerializer(many=True, read_only=True) 
    details = serializers.HyperlinkedIdentityField(view_name='findingtemplate-detail', read_only=True)
    images = serializers.HyperlinkedIdentityField(view_name='uploadedtemplateimage-list', lookup_url_kwarg='template_pk', read_only=True)  

    class Meta:
        model = FindingTemplate
        fields = [
            'id', 'created', 'updated', 'details', 'images',
            'usage_count', 'source', 'tags', 'translations', 
        ]
        read_only_fields = ['usage_count']
        extra_kwargs = {
            'tags': {'required': False, 'allow_empty': True}
        }


class FindingTemplateSerializer(FindingTemplateShortSerializer):
    lock_info = LockInfoSerializer()
    translations = FindingTemplateTranslationCreateMainSerializer(many=True, allow_empty=False)

    class Meta(FindingTemplateShortSerializer.Meta):
        fields = FindingTemplateShortSerializer.Meta.fields + ['lock_info']

    def validate_translations(self, value):
        if len(list(filter(lambda t: t.get('is_main'), value))) != 1:
            raise serializers.ValidationError('No main translation given')
        if len(set(map(lambda t: t.get('language'), value))) != len(value):
            raise serializers.ValidationError('Duplicate template language detected')
        return value
    
    @transaction.atomic
    def create(self, validated_data):
        translations_data = validated_data.pop('translations')
        instance = FindingTemplate.objects.create(**validated_data)
        translations = []
        for trd in translations_data:
            trd.pop('id', None)
            is_main = trd.pop('is_main', False)
            data = trd.pop('data', {})
            tr = FindingTemplateTranslation(template=instance, **trd)
            tr.update_data(data)
            tr.update_risk_score()
            translations.append(tr)
            if is_main:
                instance.main_translation = tr
        FindingTemplateTranslation.objects.bulk_create(translations)
        instance.save()
        return instance

    @transaction.atomic()
    def update(self, instance, validated_data):
        if 'translations' in validated_data:
            # Create/update/delete translations
            translations_data = validated_data.pop('translations', [])
            existing_translations = dict(map(lambda tr: (tr.id, tr), instance.translations.all()))
            translations_to_create = []
            translations_to_delete = []
            translations_to_update = []
            main_translation = None
            for trd in translations_data:
                is_main = trd.pop('is_main', False)
                if trd.get('id') in existing_translations:
                    tr = existing_translations[trd['id']]
                    if 'data' in trd:
                        tr.update_data(trd.pop('data'))
                    for k, v in trd.items():
                        setattr(tr, k, v)
                    translations_to_update.append(tr)
                else:
                    data = trd.pop('data', {})
                    tr = FindingTemplateTranslation(template=instance, **trd)
                    tr.pk = None
                    tr.update_data(data)
                    translations_to_create.append(tr)
                if is_main:
                    main_translation = tr
            for etr_id, etr in existing_translations.items():
                if not any(map(lambda tr: tr.get('id') == etr_id, translations_data)):
                    translations_to_delete.append(etr)

            # Update main_translation
            instance.main_translation = main_translation

            # Update cached risk_score. Inherit from main_translation if not overwritten
            for tr in translations_to_create + translations_to_update:
                tr.update_risk_score()
            
            # Update translations in DB
            if translations_to_delete:
                FindingTemplateTranslation.objects \
                    .filter(id__in=[tr.id for tr in translations_to_delete]) \
                    .delete()
            if translations_to_update:
                FindingTemplateTranslation.objects.bulk_update(
                    translations_to_update, 
                    ['language', 'status', 'custom_fields', 'title', 'risk_score', 'risk_level'])
            if translations_to_create:
                FindingTemplateTranslation.objects.bulk_create(translations_to_create)

        return super().update(instance, validated_data)


class FindingTemplateFromPentestFindingSerializer(FindingTemplateSerializer):
    project = PentestProjectRelatedField(write_only=True)

    class Meta(FindingTemplateSerializer.Meta):
        fields = FindingTemplateSerializer.Meta.fields + ['project']
    
    @transaction.atomic
    def create(self, validated_data):
        project = validated_data.pop('project')
        instance = super().create(validated_data)

        # Copy referenced images from project to template
        template_images = []
        for i in project.images.all():
            if any([f'/images/name/{i.name}' in str(tr.data) for tr in instance.translations.all()]):
                template_images.append(UploadedTemplateImage(
                    linked_object=instance,
                    name=i.name,
                    name_hash=i.name_hash,
                    file=i.file,
                    uploaded_by=i.uploaded_by,
                ))
        UploadedTemplateImage.objects.bulk_create(template_images)

        return instance
    


class NotebookPageSerializer(serializers.ModelSerializer):
    id = serializers.UUIDField(source='note_id', read_only=True)
    lock_info = LockInfoSerializer()
    title = serializers.CharField(required=False, allow_blank=True)
    text = serializers.CharField(required=False, allow_blank=True)
    parent = serializers.UUIDField(source='parent.note_id', allow_null=True, read_only=True)

    class Meta:
        model = NotebookPage
        fields = [
            'id', 'created', 'updated', 'lock_info',
            'title', 'text', 'checked', 'icon_emoji', 'status_emoji',
            'order', 'parent',
        ]
        extra_kwargs = {
            'order': {'read_only': True},
        }


class NotebookPageCreateSerializer(NotebookPageSerializer):
    parent = serializers.UUIDField(source='parent.note_id', allow_null=True, required=False)
    
    class Meta(NotebookPageSerializer.Meta):
        extra_kwargs = {
            'order': {'read_only': False, 'required': False, 'allow_null': True},
        }

    def get_notebook_object(self):
        return None
    
    def validate_parent(self, value):
        if value:
            parent = NotebookPage.objects \
                .filter(**self.get_notebook_object()) \
                .filter(note_id=value) \
                .first()
            if not parent:
                raise serializers.ValidationError('Invalid note id')
            return parent
        return value

    @transaction.atomic()
    def create(self, validated_data):
        validated_data['parent'] = validated_data.get('parent', {}).get('note_id')

        if validated_data.get('order'):
            NotebookPage.objects \
                .filter(**self.get_notebook_object()) \
                .filter(parent=validated_data.get('parent')) \
                .filter(order__gte=validated_data.get('order')) \
                .update(order=F('order') + 1)
        else:
            validated_data.pop('order', None)

        return super().create(validated_data | self.get_notebook_object())


class ProjectNotebookPageCreateSerializer(NotebookPageCreateSerializer):
    def get_notebook_object(self):
        return {'project': self.context['project']}


class UserNotebookPageCreateSerializer(NotebookPageCreateSerializer):
    def get_notebook_object(self):
        return {'user': self.context['user']}


class NotebookPageSortSerializer(serializers.ModelSerializer):
    id = serializers.UUIDField(source='note_id')
    parent = serializers.UUIDField(source='parent.note_id', allow_null=True)

    class Meta:
        model = NotebookPage
        fields = ['id', 'parent', 'order']
    
    def validate_id(self, value):
        if not next(filter(lambda n: n.note_id == value, self.parent.instance), None):
            raise serializers.ValidationError('Invalid note id')
        return value
        
    def validate_parent(self, value):
        parent = next(filter(lambda n: n.note_id == value, self.parent.instance), None)
        if value is not None and not parent:
            raise serializers.ValidationError('Invalid note id')
        return parent


class NotebookPageSortListSerializer(serializers.ListSerializer):
    def __init__(self, *args, **kwargs):
        super().__init__(child=NotebookPageSortSerializer(), *args, **kwargs)

    def update(self, instance, validated_data):
        # Update values
        missing_notes = []
        for note in instance:
            if data := next(filter(lambda d: note.note_id == d.get('note_id'), validated_data), None):
                note.parent = data.get('parent', {}).get('note_id')
                note.order = data.get('order')
            else:
                missing_notes.append(note)

        NotebookPage.objects.check_parent_and_order(instance, missing_notes)
        NotebookPage.objects.bulk_update(instance, ['parent_id', 'order'])
        return instance


class UserPublicKeySerializer(serializers.ModelSerializer):
    class Meta:
        model = UserPublicKey
        fields = ['id', 'created', 'updated', 'name', 'enabled', 'public_key', 'public_key_info']
        read_only_fields = ['public_key', 'public_key_info']


class UserPublicKeyRegisterBeginSerializer(UserPublicKeySerializer):
    class Meta(UserPublicKeySerializer.Meta):
        read_only_fields = ['public_key_info']
    
    def create(self, validated_data):
        try:
            public_key_info = pgp.public_key_info(validated_data['public_key'])
        except CryptoError as ex:
            raise serializers.ValidationError(detail=ex.args[0]) from ex

        return UserPublicKey(**validated_data | {
            'public_key_info': public_key_info
        })


class ArchivedProjectKeyPartSerializer(serializers.ModelSerializer):
    user = PentestUserSerializer(read_only=True)

    class Meta:
        model = ArchivedProjectKeyPart
        fields = ['id', 'created', 'updated', 'user', 'is_decrypted', 'decrypted_at']


class ArchivedProjectSerializer(serializers.ModelSerializer):
    key_parts = ArchivedProjectKeyPartSerializer(many=True, read_only=True)

    class Meta:
        model = ArchivedProject
        fields = ['id', 'created', 'updated', 'auto_delete_date', 'name', 'tags', 'threshold', 'key_parts']


class PentestProjectCreateArchiveSerializer(ArchivedProjectSerializer):
    @functools.cache
    def get_archive_users(self):
        return ArchivedProject.objects.get_archive_users_for_project(self.instance)

    def validate(self, attrs):
        if not self.instance.readonly:
            raise serializers.ValidationError('Cannot archive non-finished project')
        if len(self.get_archive_users()) < settings.ARCHIVING_THRESHOLD:
            raise serializers.ValidationError('Too few users')
        return super().validate(attrs)
    
    @transaction.atomic()
    def update(self, instance, validated_data):
        return ArchivedProject.objects.create_from_project(
            project=instance,
            users=self.get_archive_users(),
            delete_project=True,
        )


class ArchivedProjectPublicKeyEncryptedKeyPartSerializer(serializers.ModelSerializer):
    public_key = UserPublicKeySerializer(read_only=True)

    class Meta:
        model = ArchivedProjectPublicKeyEncryptedKeyPart
        fields = ['id', 'created', 'updated', 'public_key', 'encrypted_data']


class ArchivedProjectKeyPartDecryptSerializer(serializers.Serializer):
    data = serializers.CharField(write_only=True)

    status = serializers.ChoiceField(choices=['key-part-decrypted', 'project-restored'], read_only=True)
    project_id = serializers.UUIDField(read_only=True)

    def validate_data(self, value):
        try:
            return b64decode(value)
        except Exception:
            raise serializers.ValidationError('Invalid format. Expected base64 encoded data')

    def validate(self, attrs):
        if self.instance.is_decrypted:
            raise serializers.ValidationError('Already decrypted')
        return super().validate(attrs)

    def update(self, instance, validated_data):
        try:
            with crypto.open(io.BytesIO(instance.encrypted_key_part), mode='rb', key=crypto.EncryptionKey(id=None, key=validated_data['data'])) as c:
                instance.key_part = json.loads(c.read())
                instance.decrypted_at = timezone.now()
        except Exception as ex:
            raise serializers.ValidationError('Decryption of key part failed') from ex
        instance.save()
        output = {
            'status': 'key-part-decrypted',
            'project_id': None,
        }

        # Restore whole project when enough key parts are decrypted
        archive = self.context['archived_project']
        available_key_parts = list(archive.key_parts.exclude(decrypted_at=None))
        if len(available_key_parts) >= archive.threshold:
            project = ArchivedProject.objects.restore_project(archive)
            output |= {
                'status': 'project-restored',
                'project_id': project.id,
            }

        return output


class UploadedFileSerilaizerBase(serializers.ModelSerializer):
    compress_images = True

    resource_type = serializers.SerializerMethodField()

    class Meta:
        fields = ['id', 'created', 'updated', 'resource_type', 'name', 'file']
        extra_kwargs = {
            'file': {'write_only': True}, 
            'name': {'required': False},
        }

    def get_resource_type(self, obj) -> str:
        return None

    def get_linked_object(self):
        return None

    def create(self, validated_data):
        if self.compress_images:
            validated_data['file'], validated_data['name'] = compress_image(validated_data['file'], validated_data.get('name'))
        validated_data['linked_object'] = self.get_linked_object()
        validated_data['uploaded_by'] = self.context['request'].user
        return super().create(validated_data)


class UploadedImageSerializer(UploadedFileSerilaizerBase):
    class Meta(UploadedFileSerilaizerBase.Meta):
        model = UploadedImage

    def get_linked_object(self):
        return self.context['project']
    
    def get_resource_type(self, obj) -> str:
        return 'image'


class UploadedUserNotebookImageSerializer(UploadedFileSerilaizerBase):
    class Meta(UploadedFileSerilaizerBase.Meta):
        model = UploadedUserNotebookImage

    def get_linked_object(self):
        return self.context['user']
    
    def get_resource_type(self, obj) -> str:
        return 'image'


class UploadedTemplateImageSerializer(UploadedFileSerilaizerBase):
    class Meta(UploadedFileSerilaizerBase.Meta):
        model = UploadedTemplateImage

    def get_linked_object(self):
        return self.context['template']
    
    def get_resource_type(self, obj) -> str:
        return 'image'


class UploadedAssetSerializer(UploadedFileSerilaizerBase):
    class Meta(UploadedFileSerilaizerBase.Meta):
        model = UploadedAsset
    
    def get_linked_object(self):
        return self.context['project_type']
    
    def get_resource_type(self, obj) -> str:
        return 'asset'
    

class UploadedUserNotebookFileSerilaizer(UploadedFileSerilaizerBase):
    compress_images = False

    class Meta(UploadedFileSerilaizerBase.Meta):
        model = UploadedUserNotebookFile
    
    def get_linked_object(self):
        return self.context['user']
    
    def get_resource_type(self, obj) -> str:
        return 'file'


class UploadedProjectFileSerilaizer(UploadedFileSerilaizerBase):
    compress_images = False

    class Meta(UploadedFileSerilaizerBase.Meta):
        model = UploadedProjectFile
    
    def get_linked_object(self):
        return self.context['project']
    
    def get_resource_type(self, obj) -> str:
        return 'file'


class PreviewPdfOptionsSerializer(serializers.Serializer):
    report_template = serializers.CharField(required=False, allow_null=True, allow_blank=True, write_only=True)
    report_styles = serializers.CharField(required=False, allow_null=True, allow_blank=True, write_only=True)


class PublishPdfOptionsSerializer(serializers.Serializer):
    password = serializers.CharField(required=False, allow_null=True, allow_blank=True, write_only=True)


class PdfResponseSerializer(serializers.Serializer):
    messages = ErrorMessageSerializer(many=True, read_only=True)
    pdf = extend_schema_field(OpenApiTypes.BYTE)(serializers.CharField(allow_null=True, read_only=True))


class ImportSerializer(serializers.Serializer):
    file = serializers.FileField(write_only=True)

    id = serializers.UUIDField(read_only=True)


class ProjectTypeImportSerializer(ImportSerializer):
    scope = serializers.ChoiceField(choices=[c for c in ProjectTypeScope.choices if c[0] in [ProjectTypeScope.GLOBAL.value, ProjectTypeScope.PRIVATE.value]], write_only=True)
    
    def validate_scope(self, value):
        if value == ProjectTypeScope.PRIVATE and not settings.ENABLE_PRIVATE_DESIGNS:
            raise serializers.ValidationError(f'Scope "{value}" not supported')
        elif value == ProjectTypeScope.GLOBAL and not (self.context['request'].user.is_admin or self.context['request'].user.is_designer):
            raise exceptions.PermissionDenied()
        return value


class PentestProjectReadonlySerializer(serializers.ModelSerializer):
    class Meta:
        model = PentestProject
        fields = ['readonly']


class CopySerializer(serializers.Serializer):
    id = serializers.UUIDField(read_only=True)

    def update(self, instance, validated_data):
        return instance.copy()


class ProjectTypeCopySerializer(serializers.ModelSerializer):
    scope = serializers.ChoiceField(choices=[c for c in ProjectTypeScope.choices if c[0] in [ProjectTypeScope.GLOBAL.value, ProjectTypeScope.PRIVATE.value]])

    class Meta:
        model = ProjectType
        fields = ['id', 'name', 'scope']
        extra_kwargs = {
            'name': {'required': False},
        }
    
    def validate_scope(self, value):
        if value == ProjectTypeScope.PRIVATE and not settings.ENABLE_PRIVATE_DESIGNS:
            raise serializers.ValidationError(f'Scope "{value}" not supported')
        elif value == ProjectTypeScope.GLOBAL and not (self.context['request'].user.is_admin or self.context['request'].user.is_designer):
            raise exceptions.PermissionDenied()
        return value

    def update(self, instance, validated_data):
        return instance.copy(
            name='Copy of ' + instance.name,
            source=SourceEnum.CREATED,
            created=timezone.now(),
            **({
                ProjectTypeScope.GLOBAL: {'linked_user': None, 'linked_project': None},
                ProjectTypeScope.PRIVATE: {'linked_user': self.context['request'].user, 'linked_project': None},
            }[validated_data.pop('scope')])
        )


class PentestProjectCopySerializer(serializers.ModelSerializer):
    project_type = ProjectTypeRelatedField(required=False)

    class Meta:
        model = PentestProject
        fields = ['id', 'name', 'project_type']
        extra_kwargs = {'name': {'required': False}}

    def update(self, instance, validated_data):
        return instance.copy(
            name='Copy of ' + instance.name,
            source=SourceEnum.CREATED,
            created=timezone.now(),
            **validated_data,
        )


class PentestProjectCreateArchiveSerializer(serializers.Serializer):
    @functools.cache
    def get_archive_users(self):
        return ArchivedProject.objects.get_archive_users_for_project(self.context['project'])

    def validate(self, attrs):
        if not self.context['project'].readonly:
            raise serializers.ValidationError('Cannot archive non-finished project')
        if len(self.get_archive_users()) < settings.ARCHIVING_THRESHOLD:
            raise serializers.ValidationError('Too few users')
        return super().validate(attrs)
    
    @transaction.atomic()
    def create(self, validated_data):
        return ArchivedProject.objects.create_from_project(
            project=self.context['project'],
            users=self.get_archive_users(),
            delete_project=True,
        )


class PentestUserCheckArchiveSerializer(PentestUserSerializer):
    is_project_member = serializers.BooleanField()
    has_public_keys = serializers.BooleanField()
    can_restore = serializers.SerializerMethodField()
    warnings = serializers.SerializerMethodField()

    class Meta(PentestUserSerializer.Meta):
        fields = PentestUserSerializer.Meta.fields + ['is_active', 'is_global_archiver', 'is_project_member', 'has_public_keys', 'can_restore', 'warnings']
    
    def get_can_restore(self, obj) -> bool:
        return obj.is_active and obj.has_public_keys and (obj.is_global_archiver or obj.is_project_member)
    
    def get_warnings(self, obj) -> list[str]:
        warnings = []
        if not obj.is_active:
            warnings.append('User is not active')
        if not obj.has_public_keys:
            warnings.append('User has no public keys enabled')
        return warnings


class PentestProjectCheckArchiveSerializer(serializers.ModelSerializer):
    users = PentestUserCheckArchiveSerializer(many=True, read_only=True)

    class Meta:
        model = PentestProject
        fields = ['users']
    
    def update(self, instance, validated_data):
        return {
            'users': ArchivedProject.objects \
                .get_possible_archive_users_for_project(instance) \
                .annotate_has_public_keys() \
                .annotate(is_project_member=Exists(PentestUser.objects.filter(projectmemberinfo__project=instance).filter(pk=OuterRef('pk'))))
        }


class PentestProjectCheckSerializer(serializers.ModelSerializer):
    messages = ErrorMessageSerializer(many=True, read_only=True)

    class Meta:
        model = PentestProject
        fields = ['messages']
    
    def update(self, instance, validated_data):
        return {
            'messages': instance.perform_checks()
        }


class CustomizeProjectTypeSerializer(serializers.ModelSerializer):
    class Meta:
        model = PentestProject
        fields = ['project_type']
        read_only_fileds = ['project_type']

    def update(self, instance, validated_data):
        instance.project_type = instance.project_type.copy(
            name='Customization of ' + instance.project_type.name,
            source=SourceEnum.CUSTOMIZED,
            linked_project=instance,
            linked_user=None)
        instance.save()
        return instance


class LockableObjectSerializer(serializers.Serializer):
    id = serializers.UUIDField(read_only=True)
    lock_info = LockInfoSerializer(read_only=True)


class ExportSerializer(serializers.Serializer):
    pass

