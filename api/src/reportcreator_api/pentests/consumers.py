from functools import cached_property
import json
import logging
import random
from channels.db import database_sync_to_async
from channels.generic.websocket import AsyncJsonWebsocketConsumer, JsonWebsocketConsumer
from channels.exceptions import DenyConnection, StopConsumer

from reportcreator_api.pentests.models import PentestProject
from reportcreator_api.pentests.models.notes import ProjectNotebookPage
from reportcreator_api.pentests.serializers.notes import ProjectNotebookPageSerializer


log = logging.getLogger(__name__)


class WebsocketConsumerBase(AsyncJsonWebsocketConsumer):
    async def websocket_connect(self, message):
        try:
            user = '<none>'
            if self.scope.get('user') and not self.scope['user'].is_anonymous:
                user = self.scope['user'].username
            logging.info(f'CONNECT {self.scope['path']} (user={user})')
            return await super().websocket_connect(message)
        except Exception as ex:
            log.exception(ex)
            raise ex
    
    async def websocket_receive(self, message):
        try:
            return await super().websocket_receive(message)
        except Exception as ex:
            log.exception(ex)
            raise ex
        
    async def websocket_disconnect(self, message):
        try:
            return await super().websocket_disconnect(message)
        except StopConsumer:
            logging.info(f'DISCONNECT {self.scope['path']} (user={self.scope['user'].username})')
            raise
        except Exception as ex:
            log.exception(ex)
            raise ex
    
    @property
    def group_name(self) -> str:
        raise NotImplementedError
    
    async def has_permission(self):
        return True
    
    async def get_initial_message(self):
        return None
    
    async def connect(self):
        if not await self.has_permission():
            raise DenyConnection()

        await super().connect()
        initial_msg = await self.get_initial_message()
        if initial_msg:
            await self.send_json(initial_msg)

        await self.channel_layer.group_add(self.group_name, self.channel_name)
    
    async def disconnect(self, close_code):
        await self.channel_layer.group_discard(self.group_name, self.channel_name)
        await super().disconnect(close_code)


class ProjectNotesConsumer(WebsocketConsumerBase):
    # TODO: version number from DB (has to be an unique incremental number per text-field, not not have to be consecutive?)
    async def has_permission(self):
        user = self.scope['user']
        project = await self.get_project()
        if not user or user.is_anonymous or not project:
            return False
        if project.readonly:
            return False
        return True
    
    @property
    def project_id(self):
        return self.scope['url_route']['kwargs']['project_id']
    
    @database_sync_to_async
    def get_project(self):
        return PentestProject.objects \
            .only_permitted(self.scope['user']) \
            .filter(id=self.project_id) \
            .first()
    
    @database_sync_to_async
    def get_notes(self):
        return list(ProjectNotebookPage.objects \
            .filter(project_id=self.project_id) \
            .select_related('parent', 'assignee', 'lock_info_data__user') \
            .order_by('created'))
    
    @property
    def group_name(self) -> str:
        return f'project_notes_{self.project_id}'
    
    async def get_initial_message(self):
        notes = await self.get_notes()
        return {
            'type': 'init',
            'version': 0,  # TODO: version = current version number from DB or 0
            'data': {
                'notes': {n['id']: n for n in ProjectNotebookPageSerializer(notes, many=True).data}
            }
        }
    
    async def receive_json(self, content, **kwargs):
        msg_type = content.get('type')
        if msg_type == 'update.key':
            # TODO: validate path and value
            # TODO: apply update to DB
            await self.channel_layer.group_send(self.group_name, {
                'type': content['type'],
                'version': 0,  # TODO: version = current version number from DB or 0
                'path': content['path'],
                'value': content['value'],
            })
        elif msg_type == 'update.text':
            # TODO: validate path and value
            # TODO: apply update to DB (only update when there are document changes, ignore selection changes)
            await self.channel_layer.group_send(self.group_name, {
                'type': content['type'],
                'version': 0,  # TODO: version = current version number from DB or 0
                'path': content['path'],
                'changes': content['changes'],
            })
        else:
            raise ValueError(f'Invalid message type: {msg_type}')
        
    async def update_key(self, event):
        await self.send_json(event)

class DemoConsumer(JsonWebsocketConsumer):
    def connect(self):
        self.accept()
        self.send_json({'message': 'Hello World'})

    def receive_json(self, data):
        # TODO: validate data
        self.send_json(data)



# TODO: concurrent editing
# * [ ] server config
#   * [x] uvicorn
#   * [x] asgi+channels
#   * [ ] channels layer: postgres
# * [ ] reverse proxy config
#   * [ ] caddy
#   * [ ] nginx
# * [ ] consumers
#   * [ ] project notes
#   * [ ] user notes
# * [ ] sync with DB
#   * [ ] ypy_websocket store => django ORM
#   * [ ] post_save => ypy_websocket update message
# * [ ] frontend
#   * [ ] yjs codemirror binding
#   * [ ] integrate to pinia store / state management
#   * [ ] fallback to locking if no websocket is supported ???
#   * [ ] integrate codemirror collab with server
# * [ ] security
#   * [x] websocket authentication
#   * [x] permission checks
#   * [ ] validate YJS updates: https://discuss.yjs.dev/t/validation-security-and-middleware/2229
#   * [ ] close connection
#       * [ ] on logout
#       * [ ] on project deletion
#       * [ ] on project set readonly
#       * [ ] on user removed from project
# * [ ] tests
#   * [ ] test websocket authentication
#   * [ ] test concurrent updates
#   * [ ] test sync to DB
#   * [ ] test sync to DB => history entry
#   * [ ] test API update => update message
#   * [ ] test save signal => update message
# * [ ] other
#   * [ ] update NOTICE
