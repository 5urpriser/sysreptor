import logging
from channels.db import database_sync_to_async
from channels.generic.websocket import AsyncJsonWebsocketConsumer, JsonWebsocketConsumer
from channels.exceptions import DenyConnection, StopConsumer
from django.core.exceptions import ValidationError
from django.db import transaction

from reportcreator_api.pentests.models import PentestProject
from reportcreator_api.pentests.models.notes import ProjectNotebookPage
from reportcreator_api.pentests.serializers.notes import ProjectNotebookPageSerializer
from reportcreator_api.utils.history import history_context
from reportcreator_api.utils.utils import is_uuid


log = logging.getLogger(__name__)


class WebsocketConsumerBase(AsyncJsonWebsocketConsumer):
    async def websocket_connect(self, message):
        try:
            user = '<none>'
            if self.scope.get('user') and not self.scope['user'].is_anonymous:
                user = self.scope['user'].username
            logging.info(f'CONNECT {self.scope['path']} (user={user})')
            with history_context(history_user=self.scope.get('user')):
                return await super().websocket_connect(message)
        except Exception as ex:
            log.exception(ex)
            raise ex
    
    async def websocket_receive(self, message):
        try:
            with history_context(history_user=self.scope.get('user')):
                return await super().websocket_receive(message)
        except Exception as ex:
            log.exception(ex)
            raise ex
        
    async def websocket_disconnect(self, message):
        try:
            return await super().websocket_disconnect(message)
        except StopConsumer:
            logging.info(f'DISCONNECT {self.scope['path']} (user={self.scope['user'].username})')
            raise
        except Exception as ex:
            log.exception(ex)
            raise ex
        
    async def dispatch(self, message):
        try:
            with history_context(history_user=self.scope.get('user')):
                return await super().dispatch(message)
        except StopConsumer:
            raise
        except Exception as ex:
            log.exception(ex)
            raise ex
    
    @property
    def group_name(self) -> str:
        raise NotImplementedError
    
    async def has_permission(self):
        return True
    
    async def get_initial_message(self):
        return None
    
    async def connect(self):
        if not await self.has_permission():
            raise DenyConnection()

        await super().connect()
        initial_msg = await self.get_initial_message()
        if initial_msg:
            await self.send_json(initial_msg)

        await self.channel_layer.group_add(self.group_name, self.channel_name)
    
    async def disconnect(self, close_code):
        await self.channel_layer.group_discard(self.group_name, self.channel_name)
        await super().disconnect(close_code)


class ProjectNotesConsumer(WebsocketConsumerBase):
    # TODO: version number from DB (has to be an unique incremental number per text-field, not not have to be consecutive?)
    async def has_permission(self):
        user = self.scope['user']
        project = await self.get_project()
        if not user or user.is_anonymous or not project:
            return False
        if project.readonly:
            return False
        return True
    
    @property
    def project_id(self):
        return self.scope['url_route']['kwargs']['project_id']
    
    @database_sync_to_async
    def get_project(self):
        return PentestProject.objects \
            .only_permitted(self.scope['user']) \
            .filter(id=self.project_id) \
            .first()
    
    @property
    def group_name(self) -> str:
        return f'project_notes_{self.project_id}'
    
    @database_sync_to_async
    def get_initial_message(self):
        notes = ProjectNotebookPage.objects \
            .filter(project_id=self.project_id) \
            .select_related('parent', 'assignee', 'lock_info_data__user') \
            .order_by('created')
        return {
            'type': 'init',
            'version': 0,  # TODO: version = current version number from DB or 0
            'data': {
                'notes': {n['id']: n for n in ProjectNotebookPageSerializer(notes, many=True).data}
            }
        }
    
    async def receive_json(self, content, **kwargs):
        log.info(f'WebSocket receive_json: {content}')
        msg_type = content.get('type')
        if msg_type == 'update.key':
            await self.do_update_key(content)
            await self.channel_layer.group_send(self.group_name, {
                'type': content['type'],
                'path': content['path'],
                'value': content['value'],
            })
        elif msg_type == 'update.text':
            self.do_update_text(content)
            await self.channel_layer.group_send(self.group_name, {
                'type': content['type'],
                'version': 0,  # TODO: version = current version number from DB or 0
                'path': content['path'],
                'updates': content['updates'],
            })
        else:
            raise ValueError(f'Invalid message type: {msg_type}')
        
    def get_note_for_update(self, path, valid_paths=None):
        if not isinstance(path, str):
            raise ValidationError('Invalid path')
        path_parts = path.split('.')
        if len(path_parts) < 3 or path_parts[0] != 'notes' or not is_uuid(path_parts[1]) or not (not valid_paths or '.'.join(path_parts[2:]) in valid_paths):
            raise ValidationError('Invalid path')
        note = ProjectNotebookPage.objects \
            .filter(project_id=self.project_id) \
            .filter(note_id=path_parts[1]) \
            .select_related('parent') \
            .select_for_update(of=['self'], no_key=True) \
            .first()
        if not note:
            raise ValidationError('Invalid path')
        return note, path_parts[2]

    @database_sync_to_async
    @transaction.atomic()
    def do_update_key(self, content):
        # Validate path and get note
        valid_paths = {k for k, f in ProjectNotebookPageSerializer().fields.items() if not f.read_only} - {'title', 'text'}
        note, key = self.get_note_for_update(path=content.get('path'), valid_paths=valid_paths)

        # Update in DB
        serializer = ProjectNotebookPageSerializer(instance=note, data={key: content.get('value')}, partial=True)
        serializer.is_valid(raise_exception=True)
        note = serializer.save()

        version = 0  # TODO: version from updated DB note
        return version

    @database_sync_to_async
    @transaction.atomic()
    def do_update_text(self, content):
        # Validate path and get note
        note, key = self.get_note_for_update(path=content.get('path'), valid_paths=['title', 'text'])

        # TODO: operational transformations (with rebase_updates)
        # TODO: Update in DB

    async def update_key(self, event):
        await self.send_json(event)

    async def update_text(self, event):
        # TODO: add to (per-connection, per-field) version tracking?
        #       add to local list of updates (with version number)
        #       remove old updates (older than e.g. 1 minute)
        await self.send_json(event)


class DemoConsumer(JsonWebsocketConsumer):
    def connect(self):
        self.accept()
        self.send_json({'message': 'Hello World'})

    def receive_json(self, data):
        self.send_json(data)



# TODO: concurrent editing
# * [ ] server config
#   * [x] uvicorn
#   * [x] asgi+channels
#   * [ ] channels layer: postgres
# * [x] reverse proxy config
#   * [x] caddy => no config update required
#   * [x] nginx => requires config update
# * [ ] consumers
#   * [ ] project notes
#   * [ ] user notes
# * [ ] sync with DB
#   * [ ] websocket update => django ORM
#   * [ ] post_save signal => websocket update message
# * [ ] frontend
#   * [ ] codemirror collab: emit/receive updates
#   * [ ] emit/receive update.key messages
#   * [ ] integrate to pinia store / state management
#   * [ ] fallback to locking if no websocket is supported ???
#   * [ ] integrate codemirror collab with server
# * [ ] security
#   * [x] websocket authentication
#   * [x] permission checks
#   * [ ] close connection
#       * [ ] on logout
#       * [ ] on project deletion
#       * [ ] on project set readonly
#       * [ ] on user removed from project
# * [ ] tests
#   * [ ] test websocket authentication
#   * [ ] test concurrent updates
#   * [ ] test sync to DB
#   * [ ] test sync to DB => history entry
#   * [ ] test API update => update message
#   * [ ] test save signal => update message
# * [ ] other
#   * [ ] update NOTICE
