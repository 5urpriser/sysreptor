import json
import logging
from channels.db import database_sync_to_async
from channels.generic.websocket import AsyncWebsocketConsumer, WebsocketConsumer

from reportcreator_api.pentests.models import PentestProject
from reportcreator_api.pentests.models.notes import ProjectNotebookPage
from reportcreator_api.pentests.serializers.notes import ProjectNotebookPageSerializer


log = logging.getLogger(__name__)


class WebsocketConsumerBase(AsyncWebsocketConsumer):
    async def websocket_connect(self, message):
        try:
            return await super().websocket_connect(message)
        except Exception as ex:
            log.exception(ex)
            raise ex
    
    async def websocket_receive(self, message):
        try:
            return await super().websocket_receive(message)
        except Exception as ex:
            log.exception(ex)
            raise ex
        
    def make_room_name(self) -> str:
        raise NotImplementedError

    async def has_permission(self):
        return True
    
    async def make_initial_document(self):
        return None
    
    async def connect(self):
        if not await self.has_permission():
            await self.close()
            return
        
        await super().connect()
        initial_doc = await self.make_initial_document()
        if initial_doc:
            await self.send(text_data=json.dumps({'type': 'init', 'message': initial_doc}))

        await self.channel_layer.group_add(self.make_room_name(), self.channel_name)
    
    async def disconnect(self, close_code):
        await self.channel_layer.group_discard(self.make_room_name(), self.channel_name)
        await super().disconnect(close_code)


class ProjectNotesConsumer(WebsocketConsumerBase):
    async def has_permission(self):
        user = self.scope['user']
        project = await self.get_project()
        if not user or user.is_anonymous or not project:
            return False
        if project.readonly:
            return False
        return True
    
    @property
    def project_id(self):
        return self.scope['url_route']['kwargs']['project_id']
    
    @database_sync_to_async
    def get_project(self):
        return PentestProject.objects \
            .only_permitted(self.scope['user']) \
            .filter(id=self.project_id) \
            .first()
    
    @database_sync_to_async
    def get_notes(self):
        return list(ProjectNotebookPage.objects \
            .filter(project_id=self.project_id) \
            .select_related('parent', 'assignee', 'lock_info_data__user') \
            .order_by('created'))
    
    def make_room_name(self) -> str:
        return f'project_notes_{self.project_id}'
    
    async def make_initial_document(self):
        # TODO: dummy data
        return {'message': 'Hello World'}
    

class DemoConsumer(WebsocketConsumer):
    def connect(self):
        self.accept()
        self.send(text_data=json.dumps({'message': 'Hello World'}))

    def receive(self, text_data):
        text_data_json = json.loads(text_data)
        message = text_data_json["message"]

        self.send(text_data=json.dumps({"message": message}))



# TODO: concurrent editing
# * [ ] server config
#   * [x] uvicorn
#   * [x] asgi+channels
#   * [ ] channels layer: postgres
# * [ ] reverse proxy config
#   * [ ] caddy
#   * [ ] nginx
# * [ ] consumers
#   * [ ] project notes
#   * [ ] user notes
# * [ ] sync with DB
#   * [ ] ypy_websocket store => django ORM
#   * [ ] post_save => ypy_websocket update message
# * [ ] frontend
#   * [ ] yjs codemirror binding
#   * [ ] integrate to pinia store / state management
#   * [ ] fallback to locking if no websocket is supported ???
# * [ ] security
#   * [x] websocket authentication
#   * [x] permission checks
#   * [ ] validate YJS updates: https://discuss.yjs.dev/t/validation-security-and-middleware/2229
#   * [ ] close connection
#       * [ ] on logout
#       * [ ] on project deletion
#       * [ ] on project set readonly
#       * [ ] on user removed from project
# * [ ] tests
#   * [ ] test websocket authentication
#   * [ ] test concurrent updates
#   * [ ] test sync to DB
#   * [ ] test sync to DB => history entry
#   * [ ] test API update => update message
#   * [ ] test save signal => update message
# * [ ] other
#   * [ ] update NOTICE
