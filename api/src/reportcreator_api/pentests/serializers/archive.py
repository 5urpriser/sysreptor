from base64 import b64decode
import functools
import io
import json
from typing import Optional
from django.conf import settings
from rest_framework import serializers
from django.db import transaction
from django.db.models import Exists, OuterRef
from django.utils import timezone
from reportcreator_api.archive import crypto

from reportcreator_api.archive.crypto import pgp, CryptoError
from reportcreator_api.pentests.models import UserPublicKey, ArchivedProject, ArchivedProjectKeyPart, ArchivedProjectPublicKeyEncryptedKeyPart, PentestProject
from reportcreator_api.users.models import PentestUser
from reportcreator_api.users.serializers import PentestUserSerializer


class UserPublicKeySerializer(serializers.ModelSerializer):
    class Meta:
        model = UserPublicKey
        fields = ['id', 'created', 'updated', 'name', 'enabled', 'public_key', 'public_key_info']
        read_only_fields = ['public_key', 'public_key_info']


class UserPublicKeyRegisterBeginSerializer(UserPublicKeySerializer):
    class Meta(UserPublicKeySerializer.Meta):
        read_only_fields = ['public_key_info']
    
    def create(self, validated_data):
        try:
            public_key_info = pgp.public_key_info(validated_data['public_key'])
        except CryptoError as ex:
            raise serializers.ValidationError(detail=ex.args[0]) from ex

        return UserPublicKey(**validated_data | {
            'public_key_info': public_key_info
        })


class ArchivedProjectKeyPartSerializer(serializers.ModelSerializer):
    user = PentestUserSerializer(read_only=True)

    class Meta:
        model = ArchivedProjectKeyPart
        fields = ['id', 'created', 'updated', 'user', 'is_decrypted', 'decrypted_at']


class ArchivedProjectSerializer(serializers.ModelSerializer):
    key_parts = ArchivedProjectKeyPartSerializer(many=True, read_only=True)
    reencrypt_key_parts_after_inactivity_date = serializers.SerializerMethodField()

    class Meta:
        model = ArchivedProject
        fields = ['id', 'created', 'updated', 'auto_delete_date', 'reencrypt_key_parts_after_inactivity_date', 'name', 'tags', 'threshold', 'key_parts']

    def get_reencrypt_key_parts_after_inactivity_date(self, obj) -> Optional[str]:
        decrypted_dates = [k.decrypted_at for k in obj.key_parts.all() if k.is_decrypted]
        if not decrypted_dates:
            return None
        return max(decrypted_dates) + settings.AUTOMATICALLY_RESET_STALE_ARCHIVE_RESTORES_AFTER


class PentestProjectCreateArchiveSerializer(ArchivedProjectSerializer):
    @functools.cache
    def get_archive_users(self):
        return ArchivedProject.objects.get_archive_users_for_project(self.instance)

    def validate(self, attrs):
        if not self.instance.readonly:
            raise serializers.ValidationError('Cannot archive non-finished project')
        if len(self.get_archive_users()) < settings.ARCHIVING_THRESHOLD:
            raise serializers.ValidationError('Too few users')
        return super().validate(attrs)
    
    @transaction.atomic()
    def update(self, instance, validated_data):
        return ArchivedProject.objects.create_from_project(
            project=instance,
            users=self.get_archive_users(),
            delete_project=True,
        )


class ArchivedProjectPublicKeyEncryptedKeyPartSerializer(serializers.ModelSerializer):
    public_key = UserPublicKeySerializer(read_only=True)

    class Meta:
        model = ArchivedProjectPublicKeyEncryptedKeyPart
        fields = ['id', 'created', 'updated', 'public_key', 'encrypted_data']


class ArchivedProjectKeyPartDecryptSerializer(serializers.Serializer):
    data = serializers.CharField(write_only=True)

    status = serializers.ChoiceField(choices=['key-part-decrypted', 'project-restored'], read_only=True)
    project_id = serializers.UUIDField(read_only=True)

    def validate_data(self, value):
        try:
            return b64decode(value)
        except Exception:
            raise serializers.ValidationError('Invalid format. Expected base64 encoded data')

    def validate(self, attrs):
        if self.instance.is_decrypted:
            raise serializers.ValidationError('Already decrypted')
        return super().validate(attrs)

    def update(self, instance, validated_data):
        try:
            with crypto.open(io.BytesIO(instance.encrypted_key_part), mode='rb', key=crypto.EncryptionKey(id=None, key=validated_data['data'])) as c:
                instance.key_part = json.loads(c.read())
                instance.decrypted_at = timezone.now()
        except Exception as ex:
            raise serializers.ValidationError('Decryption of key part failed') from ex
        instance.save()
        output = {
            'status': 'key-part-decrypted',
            'project_id': None,
        }

        # Restore whole project when enough key parts are decrypted
        archive = self.context['archived_project']
        available_key_parts = list(archive.key_parts.exclude(decrypted_at=None))
        if len(available_key_parts) >= archive.threshold:
            project = ArchivedProject.objects.restore_project(archive)
            output |= {
                'status': 'project-restored',
                'project_id': project.id,
            }

        return output


class PentestProjectCreateArchiveSerializer(serializers.Serializer):
    @functools.cache
    def get_archive_users(self):
        return ArchivedProject.objects.get_archive_users_for_project(self.context['project'])

    def validate(self, attrs):
        if not self.context['project'].readonly:
            raise serializers.ValidationError('Cannot archive non-finished project')
        if len(self.get_archive_users()) < settings.ARCHIVING_THRESHOLD:
            raise serializers.ValidationError('Too few users')
        return super().validate(attrs)
    
    @transaction.atomic()
    def create(self, validated_data):
        return ArchivedProject.objects.create_from_project(
            project=self.context['project'],
            users=self.get_archive_users(),
            delete_project=True,
        )


class PentestUserCheckArchiveSerializer(PentestUserSerializer):
    is_project_member = serializers.BooleanField()
    has_public_keys = serializers.BooleanField()
    can_restore = serializers.SerializerMethodField()
    warnings = serializers.SerializerMethodField()

    class Meta(PentestUserSerializer.Meta):
        fields = PentestUserSerializer.Meta.fields + ['is_active', 'is_global_archiver', 'is_project_member', 'has_public_keys', 'can_restore', 'warnings']
    
    def get_can_restore(self, obj) -> bool:
        return obj.is_active and obj.has_public_keys and (obj.is_global_archiver or obj.is_project_member)
    
    def get_warnings(self, obj) -> list[str]:
        warnings = []
        if not obj.is_active:
            warnings.append('User is not active')
        if not obj.has_public_keys:
            warnings.append('User has no public keys enabled')
        return warnings
    

class PentestProjectCheckArchiveSerializer(serializers.ModelSerializer):
    users = PentestUserCheckArchiveSerializer(many=True, read_only=True)

    class Meta:
        model = PentestProject
        fields = ['users']
    
    def update(self, instance, validated_data):
        return {
            'users': ArchivedProject.objects \
                .get_possible_archive_users_for_project(instance) \
                .annotate_has_public_keys() \
                .annotate(is_project_member=Exists(PentestUser.objects.filter(projectmemberinfo__project=instance).filter(pk=OuterRef('pk'))))
        }



