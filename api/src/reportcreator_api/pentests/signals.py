import functools
import operator
from django.conf import settings
from django.db.models import signals
from django.dispatch import receiver
from django.utils import timezone
from simple_history.signals import pre_create_historical_record
from reportcreator_api.pentests.models.project import ProjectMemberInfo

from reportcreator_api.utils.models import HistoricalRecords, bulk_create_with_history, bulk_delete_with_history, bulk_update_with_history, disable_for_loaddata, history_context
from reportcreator_api.pentests.customfields.types import parse_field_definition
from reportcreator_api.pentests.customfields.utils import HandleUndefinedFieldsOptions, ensure_defined_structure, has_field_structure_changed
from reportcreator_api.pentests.models import PentestFinding, PentestProject, ProjectType, ReportSection, UploadedAsset, UploadedImage, \
    UploadedProjectFile, UploadedUserNotebookImage, UploadedUserNotebookFile, UploadedTemplateImage, ArchivedProject, \
    FindingTemplate, FindingTemplateTranslation, ProjectNotebookPage


@receiver(signals.pre_save, sender=PentestProject)
@disable_for_loaddata
def project_set_readonly_since(sender, instance, *args, **kwargs):
    if instance.readonly and not instance.readonly_since:
        instance.readonly_since = timezone.now()
    elif not instance.readonly and instance.readonly_since:
        instance.readonly_since = None


def update_project_report_sections_structure(projects, project_type, patch_previous_project_history=False):
    # Update structure of all reports using that project_type
    sections_to_create = []
    sections_to_delete = []
    sections_to_update = []
    for project in projects:
        # Merge all report data (sections + project.unknown_custom_fields) and update structure
        data_all = ensure_defined_structure(
            value=(project.unknown_custom_fields or {}) | functools.reduce(operator.or_, map(lambda s: s.custom_fields, project.sections.all()), {}),
            definition=project_type.report_fields_obj,
            handle_undefined=HandleUndefinedFieldsOptions.FILL_DEFAULT,
            include_unknown=True
        )
        # Check which sections to create/delete/update
        sections = []
        existing_sections = {s.section_id: s for s in project.sections.all()}
        
        # New sections
        for sid in {s['id'] for s in project_type.report_sections} - set(existing_sections.keys()):
            section = ReportSection(project=project, section_id=sid)
            sections.append(section)
            sections_to_create.append(section)
        # Deleted sections
        for sid in set(existing_sections.keys()) - {s['id'] for s in project_type.report_sections}:
            sections_to_delete.append(existing_sections[sid])
        # Updated sections
        for sid in set(existing_sections.keys()).intersection({s['id'] for s in project_type.report_sections}):
            section = existing_sections[sid]
            sections.append(section)
            sections_to_update.append(section)

        # Distribute data to sections
        for section in sections:
            section_fields = next(filter(lambda s: s['id'] == section.section_id, project_type.report_sections))['fields']
            section.custom_fields = {f: data_all.pop(f) for f in section_fields}
        # Store remaining unknown fields on project
        project.unknown_custom_fields = data_all if data_all else None

    # Persist changes in DB
    bulk_update_with_history(ReportSection, filter(lambda s: s.has_changed, sections_to_update), fields=['custom_fields'])
    bulk_create_with_history(ReportSection, sections_to_create)
    bulk_delete_with_history(ReportSection, sections_to_delete)
    projects_to_update = list(filter(lambda p: p.has_changed, projects))
    if patch_previous_project_history and settings.SIMPLE_HISTORY_ENABLED:
        # Update the unknown_custom_fields in the previous history entry to have a clean history timeline
        PentestProject.objects.bulk_update(projects_to_update, fields=['unknown_custom_fields'])
        project_histories = PentestProject.history.filter(id__in=[p.id for p in projects]).latest_of_each()
        for ph in project_histories:
            ph.unknown_custom_fields = next(filter(lambda p: p.id == ph.id, projects)).unknown_custom_fields
        PentestProject.history.bulk_update(project_histories, fields=['unknown_custom_fields'])
    else:
        bulk_update_with_history(PentestProject, projects_to_update, fields=['unknown_custom_fields'])


@receiver(signals.post_save, sender=PentestProject)
@disable_for_loaddata
def project_project_type_changed_postsave(sender, instance, created, *args, **kwargs):
    """
    When the project_type of a project changed, update the structure of all fields
    """
    if created or 'project_type_id' in instance.changed_fields:
        with history_context(history_date=timezone.now(), history_prevent_cleanup=True, history_change_reason='Design changed'):
            # Update report sections
            update_project_report_sections_structure(projects=[instance], project_type=instance.project_type, patch_previous_project_history=True)
            instance.clear_changed_fields()

            # Update finding fields
            updated_findings = list(instance.findings.all().select_related('project__project_type'))
            for finding in updated_findings:
                finding.update_data(ensure_defined_structure(
                    value=finding.data_all, 
                    definition=instance.project_type.finding_fields_obj, 
                    handle_undefined=HandleUndefinedFieldsOptions.FILL_DEFAULT,
                    include_unknown=True))
            bulk_update_with_history(PentestFinding, objs=filter(lambda f: f.has_changed, updated_findings), fields=['custom_fields'])


@receiver(signals.post_save, sender=ProjectType)
@disable_for_loaddata
def project_type_field_definition_changed(sender, instance, *args, **kwargs):
    """
    When report_fields or finding_fields structure changed, update the field structure of all projects that are based on this project_type
    """
    with history_context(history_date=timezone.now(), history_change_reason='Field definition changed', history_prevent_cleanup=True):
        # Check if finding field definition changed
        if (diff := instance.get_field_diff('finding_fields')) and has_field_structure_changed(parse_field_definition(diff[0]), instance.finding_fields_obj):
            # Update structure of all findings of this project_type
            updated_findings = list(PentestFinding.objects.filter(project__project_type=instance).select_related('project__project_type'))
            for finding in updated_findings:
                finding.update_data(ensure_defined_structure(
                    value=finding.data_all, 
                    definition=instance.finding_fields_obj, 
                    handle_undefined=HandleUndefinedFieldsOptions.FILL_DEFAULT,
                    include_unknown=True))
            bulk_update_with_history(PentestFinding, objs=filter(lambda f: f.has_changed, updated_findings), fields=['custom_fields'])

        # Check if report section definition changed.
        # Report sections are considered as changed if report_fields definitions changed or 
        # sections are created/deleted or fields are moved between sections
        # Changes in the section definition are synced to the ReportSection models of projects.
        report_fields_diff = instance.get_field_diff('report_fields')
        report_fields_changed = report_fields_diff and has_field_structure_changed(parse_field_definition(report_fields_diff[0]), instance.report_fields_obj)
        report_sections_diff = instance.get_field_diff('report_sections')
        report_sections_prev = set([(s['id'], tuple(sorted(s['fields']))) for s in report_sections_diff[0]]) if report_sections_diff else set()
        report_sections_curr = set([(s['id'], tuple(sorted(s['fields']))) for s in report_sections_diff[1]]) if report_sections_diff else set()
        report_sections_changed = report_sections_diff and (report_sections_prev != report_sections_curr)
        if report_fields_changed or report_sections_changed:
            projects = list(PentestProject.objects.filter(project_type=instance).select_related('project_type').prefetch_related('sections'))
            update_project_report_sections_structure(projects=projects, project_type=instance)


@receiver(pre_create_historical_record)
def history_set_details(instance, history_instance, *args, **kwargs):
    history_instance.history_prevent_cleanup = getattr(history_instance, '_history_prevent_cleanup', 
                                                       getattr(HistoricalRecords.context, 'history_prevent_cleanup', False))
    history_instance.history_date = getattr(instance, '_history_date', None) or \
        getattr(HistoricalRecords.context, 'history_date', None) or \
        timezone.now()
    history_instance.history_change_reason = getattr(instance, '_history_change_reason', 
                                                     getattr(HistoricalRecords.context, 'history_change_reason', None))
    if history_type := getattr(instance, '_history_type', None):
        history_instance.history_type = history_type
    if history_instance.history_type in ['+', '-']:
        history_instance.history_prevent_cleanup = True

    # Model-specific change_reason
    if history_instance.history_type == '~' and not history_instance.history_change_reason:
        if isinstance(instance, FindingTemplateTranslation):
            if 'language' in instance.changed_fields:
                history_instance.history_change_reason = 'Language changed'
            elif 'status' in instance.changed_fields:
                history_instance.history_change_reason = 'Status changed'
        elif isinstance(instance, FindingTemplate):
            if 'main_translation_id' in instance.changed_fields:
                history_instance.history_change_reason = 'Main translation changed'
        elif isinstance(instance, (PentestFinding, ReportSection, ProjectNotebookPage)):
            if 'status' in instance.changed_fields:
                history_instance.history_change_reason = 'Status changed'
            elif 'assignee_id' in instance.changed_fields:
                history_instance.history_change_reason = 'Assignee changed'
        elif isinstance(instance, ProjectMemberInfo):
            if 'roles' in instance.changed_fields:
                history_instance.history_change_reason = 'Roles changed'
        elif isinstance(instance, PentestProject):
            if 'project_type_id' in instance.changed_fields:
                history_instance.history_change_reason = 'Design changed'
            elif 'language' in instance.changed_fields:
                history_instance.history_change_reason = 'Language changed'
        elif isinstance(instance, ProjectType):
            if set(instance.changed_fields).intersection(['report_fields', 'report_sections', 'finding_fields', 'finding_field_order', 'finding_ordering']):
                history_instance.history_change_reason = 'Field definition changed'
            elif 'language' in instance.changed_fields:
                history_instance.history_change_reason = 'Language changed'
        
        if history_instance.history_change_reason:
            history_instance.history_prevent_cleanup = True


@receiver(signals.post_delete, sender=PentestProject)
@receiver(signals.post_delete, sender=ProjectType)
@receiver(signals.post_delete, sender=FindingTemplate)
def delete_history(sender, instance, *args, **kwargs):
    # On delete of main models: cascade delete all related histories
    if sender == PentestProject:
        instance.history.all().delete()
        PentestFinding.history.filter(project_id=instance.id).delete()
        ReportSection.history.filter(project_id=instance.id).delete()
        ProjectNotebookPage.history.filter(project_id=instance.id).delete()
        UploadedProjectFile.history.filter(linked_object_id=instance.id).delete()
        UploadedImage.history.filter(linked_object_id=instance.id).delete()
    elif sender == ProjectType:
        instance.history.all().delete()
        UploadedAsset.history.filter(linked_object_id=instance.id).delete()
    elif sender == FindingTemplate:
        instance.history.all().delete()
        FindingTemplateTranslation.history.filter(template_id=instance.id).delete()
        UploadedTemplateImage.history.filter(linked_object_id=instance.id).delete()


@receiver(signals.post_delete, sender=UploadedAsset)
@receiver(signals.post_delete, sender=UploadedAsset.history.model)
@receiver(signals.post_delete, sender=UploadedImage)
@receiver(signals.post_delete, sender=UploadedImage.history.model)
@receiver(signals.post_delete, sender=UploadedProjectFile)
@receiver(signals.post_delete, sender=UploadedProjectFile.history.model)
@receiver(signals.post_delete, sender=UploadedTemplateImage)
@receiver(signals.post_delete, sender=UploadedTemplateImage.history.model)
@receiver(signals.post_delete, sender=UploadedUserNotebookImage)
@receiver(signals.post_delete, sender=UploadedUserNotebookFile)
@receiver(signals.post_delete, sender=ArchivedProject)
def uploaded_file_deleted(sender, instance, *args, **kwargs):
    if not instance.file:
        return
    
    storage = sender.instance_type.file.field.storage if hasattr(sender, 'instance_type') else sender.file.field.storage

    # Delete file when instance is deleted from DB and file on filesystem is no loger referenced
    models = [
        UploadedAsset,
        UploadedImage,
        UploadedProjectFile,
        UploadedTemplateImage,
        UploadedUserNotebookImage,
        UploadedUserNotebookFile,
        ArchivedProject,
    ]
    qs = UploadedImage.objects.none()
    for m in models:
        if m.file.field.storage == storage:
            qs = qs.union(m.objects.filter(file=instance.file))
            if hasattr(m, 'history'):
                qs = qs.union(m.history.filter(file=instance.file))

    is_file_referenced = qs.exists()
    if not is_file_referenced:
        try:
            if isinstance(instance.file, str):
                storage.delete(instance.file)
            else:
                instance.file.delete(save=False)
        except (FileNotFoundError, OSError):
            # Ignore file not found. We would have deleted it anyway
            pass
