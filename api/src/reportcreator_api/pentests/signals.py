import functools
import operator
from django.db.models import signals
from django.dispatch import receiver
from django.utils import timezone
from reportcreator_api.pentests.customfields.types import parse_field_definition
from reportcreator_api.pentests.customfields.utils import HandleUndefinedFieldsOptions, ensure_defined_structure, has_field_structure_changed

from reportcreator_api.pentests.models import PentestFinding, PentestProject, ProjectType, ReportSection, UploadedAsset, UploadedImage, \
    UploadedProjectFile, UploadedUserNotebookImage, UploadedUserNotebookFile, UploadedTemplateImage
from reportcreator_api.pentests.models.archive import ArchivedProject
from reportcreator_api.utils.models import disable_for_loaddata


@receiver(signals.pre_save, sender=PentestProject)
@disable_for_loaddata
def project_set_readonly_since(sender, instance, *args, **kwargs):
    if instance.readonly and not instance.readonly_since:
        instance.readonly_since = timezone.now()
    elif not instance.readonly and instance.readonly_since:
        instance.readonly_since = None


def update_project_report_sections_structure(projects, project_type):
    # Update structure of all reports using that project_type
    sections_to_create = []
    sections_to_delete = []
    sections_to_update = []
    for project in projects:
        # Merge all report data (sections + project.unknown_custom_fields) and update structure
        data_all = ensure_defined_structure(
            value=(project.unknown_custom_fields or {}) | functools.reduce(operator.or_, map(lambda s: s.custom_fields, project.sections.all()), {}),
            definition=project_type.report_fields_obj,
            handle_undefined=HandleUndefinedFieldsOptions.FILL_DEFAULT,
            include_unknown=True
        )
        # Check which sections to create/delete/update
        sections = []
        existing_sections = {s.section_id: s for s in project.sections.all()}
        
        # New sections
        for sid in {s['id'] for s in project_type.report_sections} - set(existing_sections.keys()):
            section = ReportSection(project=project, section_id=sid)
            sections.append(section)
            sections_to_create.append(section)
        # Deleted sections
        for sid in set(existing_sections.keys()) - {s['id'] for s in project_type.report_sections}:
            sections_to_delete.append(existing_sections[sid])
        # Updated sections
        for sid in set(existing_sections.keys()).intersection({s['id'] for s in project_type.report_sections}):
            section = existing_sections[sid]
            sections.append(section)
            sections_to_update.append(section)

        # Distribute data to sections
        for section in sections:
            section_fields = next(filter(lambda s: s['id'] == section.section_id, project_type.report_sections))['fields']
            section.custom_fields = {f: data_all.pop(f) for f in section_fields}
        # Store remaining unknown fields on project
        project.unknown_custom_fields = data_all if data_all else None

    # Persist changes in DB
    PentestProject.objects.bulk_update(filter(lambda p: p.has_changed, projects), fields=['unknown_custom_fields'])
    ReportSection.objects.bulk_update(filter(lambda s: s.has_changed, sections_to_update), fields=['custom_fields'])
    ReportSection.objects.bulk_create(sections_to_create)
    ReportSection.objects.filter(id__in=map(lambda s: s.id, sections_to_delete)).delete()


@receiver(signals.post_save, sender=PentestProject)
@disable_for_loaddata
def project_project_type_changed_postsave(sender, instance, created, *args, **kwargs):
    """
    When the project_type of a project changed, update the structure of all fields
    """
    if created or 'project_type_id' in instance.changed_fields:
        # Update report sections
        update_project_report_sections_structure(projects=[instance], project_type=instance.project_type)

        # Update finding fields
        updated_findings = list(instance.findings.all().select_related('project__project_type'))
        for finding in updated_findings:
            finding.update_data(ensure_defined_structure(
                value=finding.data_all, 
                definition=instance.project_type.finding_fields_obj, 
                handle_undefined=HandleUndefinedFieldsOptions.FILL_DEFAULT,
                include_unknown=True))
        PentestFinding.objects.bulk_update(
            filter(lambda f: f.has_changed, updated_findings), 
            fields=['custom_fields'])


@receiver(signals.post_save, sender=ProjectType)
@disable_for_loaddata
def project_type_field_definition_changed(sender, instance, *args, **kwargs):
    """
    When report_fields or finding_fields structure changed, update the field structure of all projects that are based on this project_type
    """
    # Check if finding field definition changed
    if (diff := instance.get_field_diff('finding_fields')) and has_field_structure_changed(parse_field_definition(diff[0]), instance.finding_fields_obj):
        # Update structure of all findings of this project_type
        updated_findings = list(PentestFinding.objects.filter(project__project_type=instance).select_related('project__project_type'))
        for finding in updated_findings:
            finding.update_data(ensure_defined_structure(
                value=finding.data_all, 
                definition=instance.finding_fields_obj, 
                handle_undefined=HandleUndefinedFieldsOptions.FILL_DEFAULT,
                include_unknown=True))
        PentestFinding.objects.bulk_update(updated_findings, fields=['custom_fields'])

    # Check if report section definition changed.
    # Report sections are considered as changed if report_fields definitions changed or 
    # sections are created/deleted or fields are moved between sections
    # Changes in the section definition are synced to the ReportSection models of projects.
    report_fields_diff = instance.get_field_diff('report_fields')
    report_fields_changed = report_fields_diff and has_field_structure_changed(parse_field_definition(report_fields_diff[0]), instance.report_fields_obj)
    report_sections_diff = instance.get_field_diff('report_sections')
    report_sections_prev = set([(s['id'], tuple(sorted(s['fields']))) for s in report_sections_diff[0]]) if report_sections_diff else set()
    report_sections_curr = set([(s['id'], tuple(sorted(s['fields']))) for s in report_sections_diff[1]]) if report_sections_diff else set()
    report_sections_changed = report_sections_diff and (report_sections_prev != report_sections_curr)
    if report_fields_changed or report_sections_changed:
       projects = list(PentestProject.objects.filter(project_type=instance).select_related('project_type').prefetch_related('sections'))
       update_project_report_sections_structure(projects=projects, project_type=instance)


@receiver(signals.post_delete, sender=UploadedAsset)
@receiver(signals.post_delete, sender=UploadedAsset.history.model)
@receiver(signals.post_delete, sender=UploadedImage)
@receiver(signals.post_delete, sender=UploadedImage.history.model)
@receiver(signals.post_delete, sender=UploadedProjectFile)
@receiver(signals.post_delete, sender=UploadedProjectFile.history.model)
@receiver(signals.post_delete, sender=UploadedTemplateImage)
@receiver(signals.post_delete, sender=UploadedTemplateImage.history.model)
@receiver(signals.post_delete, sender=UploadedUserNotebookImage)
@receiver(signals.post_delete, sender=UploadedUserNotebookFile)
@receiver(signals.post_delete, sender=ArchivedProject)
def uploaded_file_deleted(sender, instance, *args, **kwargs):
    # Delete file when instance is deleted from DB and file on filesystem is no loger referenced
    if instance.file:
        models = [
            UploadedAsset,
            UploadedImage,
            UploadedTemplateImage,
            UploadedUserNotebookImage,
            UploadedUserNotebookFile,
            UploadedProjectFile,
            ArchivedProject,
        ]
        qs = UploadedImage.objects.none()
        for m in models:
            qs = qs.union(m.objects.filter(file=instance.file))
            if hasattr(m, 'hisotry'):
                qs = qs.union(m.history.model.objects.filter(file=instance.file))

        is_file_referenced = qs.exists()
        if not is_file_referenced:
            instance.file.delete(save=False)
