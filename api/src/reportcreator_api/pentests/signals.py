import functools
import operator
from django.conf import settings
from django.db.models import signals
from django.dispatch import receiver
from django.utils import timezone
from simple_history.signals import pre_create_historical_record

from reportcreator_api.pentests.models.project import ProjectMemberInfo
from reportcreator_api.utils.utils import omit_keys
from reportcreator_api.utils.models import disable_for_loaddata
from reportcreator_api.utils.history import HistoricalRecords, bulk_create_with_history, bulk_delete_with_history, bulk_update_with_history, history_context
from reportcreator_api.pentests.customfields.types import parse_field_definition
from reportcreator_api.pentests.customfields.utils import HandleUndefinedFieldsOptions, ensure_defined_structure, has_field_structure_changed
from reportcreator_api.pentests.models import PentestFinding, PentestProject, ProjectType, ReportSection, UploadedAsset, UploadedImage, \
    UploadedProjectFile, UploadedUserNotebookImage, UploadedUserNotebookFile, UploadedTemplateImage, ArchivedProject, \
    FindingTemplate, FindingTemplateTranslation, ProjectNotebookPage, SourceEnum, \
    OperationalTransformationEvent, OperationalTransformationEventType
from reportcreator_api.pentests.models.collab import collab_context_store


@receiver(signals.pre_save, sender=PentestProject)
@disable_for_loaddata
def project_set_readonly_since(sender, instance, *args, **kwargs):
    if instance.readonly and not instance.readonly_since:
        instance.readonly_since = timezone.now()
        instance._history_prevent_cleanup = True
        instance._history_change_reason = 'Finished project'
    elif not instance.readonly and instance.readonly_since:
        instance.readonly_since = None
        instance._history_prevent_cleanup = True
        instance._history_change_reason = 'Re-activated project'


@receiver(signals.post_save, sender=PentestProject)
@disable_for_loaddata
def project_set_readonly_history(sender, instance, *args, **kwargs):
    if not (instance.readonly and 'readonly' in instance.changed_fields and settings.SIMPLE_HISTORY_ENABLED):
        return
    
    # Prevent cleanup of history savepoints at time of marking the project readonly
    ReportSection.history.filter(project_id=instance.id).latest_of_each().update(history_prevent_cleanup=True)
    PentestFinding.history.filter(project_id=instance.id).latest_of_each().update(history_prevent_cleanup=True)
    ProjectNotebookPage.history.filter(project_id=instance.id).latest_of_each().update(history_prevent_cleanup=True)
    ProjectMemberInfo.history.filter(project_id=instance.id).latest_of_each().update(history_prevent_cleanup=True)
    UploadedImage.history.filter(linked_object_id=instance.id).latest_of_each().update(history_prevent_cleanup=True)
    UploadedProjectFile.history.filter(linked_object_id=instance.id).latest_of_each().update(history_prevent_cleanup=True)


def update_project_report_sections_structure(projects, project_type, patch_previous_project_history=False):
    # Update structure of all reports using that project_type
    sections_to_create = []
    sections_to_delete = []
    sections_to_update = []
    for project in projects:
        # Merge all report data (sections + project.unknown_custom_fields) and update structure
        data_all = ensure_defined_structure(
            value=(project.unknown_custom_fields or {}) | functools.reduce(operator.or_, map(lambda s: s.custom_fields, project.sections.all()), {}),
            definition=project_type.report_fields_obj,
            handle_undefined=HandleUndefinedFieldsOptions.FILL_DEFAULT,
            include_unknown=True
        )
        # Check which sections to create/delete/update
        sections = []
        existing_sections = {s.section_id: s for s in project.sections.all()}
        
        # New sections
        for sid in {s['id'] for s in project_type.report_sections} - set(existing_sections.keys()):
            section = ReportSection(project=project, section_id=sid)
            sections.append(section)
            sections_to_create.append(section)
        # Deleted sections
        for sid in set(existing_sections.keys()) - {s['id'] for s in project_type.report_sections}:
            sections_to_delete.append(existing_sections[sid])
        # Updated sections
        for sid in set(existing_sections.keys()).intersection({s['id'] for s in project_type.report_sections}):
            section = existing_sections[sid]
            sections.append(section)
            sections_to_update.append(section)

        # Distribute data to sections
        for section in sections:
            section_fields = next(filter(lambda s: s['id'] == section.section_id, project_type.report_sections))['fields']
            section.custom_fields = {f: data_all.pop(f) for f in section_fields}
        # Store remaining unknown fields on project
        project.unknown_custom_fields = data_all if data_all else None

    # Persist changes in DB
    bulk_update_with_history(ReportSection, filter(lambda s: s.has_changed, sections_to_update), fields=['custom_fields'])
    bulk_create_with_history(ReportSection, sections_to_create)
    bulk_delete_with_history(ReportSection, sections_to_delete)
    projects_to_update = list(filter(lambda p: p.has_changed, projects))
    if patch_previous_project_history and settings.SIMPLE_HISTORY_ENABLED:
        # Update the unknown_custom_fields in the previous history entry to have a clean history timeline
        PentestProject.objects.bulk_update(projects_to_update, fields=['unknown_custom_fields'])
        project_histories = PentestProject.history.filter(id__in=[p.id for p in projects]).latest_of_each()
        for ph in project_histories:
            ph.unknown_custom_fields = next(filter(lambda p: p.id == ph.id, projects)).unknown_custom_fields
        PentestProject.history.bulk_update(project_histories, fields=['unknown_custom_fields'])
    else:
        bulk_update_with_history(PentestProject, projects_to_update, fields=['unknown_custom_fields'])


@receiver(signals.post_save, sender=PentestProject)
@disable_for_loaddata
def project_project_type_changed_postsave(sender, instance, created, *args, **kwargs):
    """
    When the project_type of a project changed, update the structure of all fields
    """
    # Project created or project_type changed
    if created or 'project_type_id' in instance.changed_fields:
        with history_context(history_prevent_cleanup=True, **({'history_change_reason': 'Design changed'} if not created else {})):
            # Update report sections
            update_project_report_sections_structure(projects=[instance], project_type=instance.project_type, patch_previous_project_history=True)
            instance.clear_changed_fields()

            # Update finding fields
            updated_findings = list(instance.findings.all().select_related('project__project_type'))
            for finding in updated_findings:
                finding.update_data(ensure_defined_structure(
                    value=finding.data_all, 
                    definition=instance.project_type.finding_fields_obj, 
                    handle_undefined=HandleUndefinedFieldsOptions.FILL_DEFAULT,
                    include_unknown=True))
            if settings.SIMPLE_HISTORY_ENABLED:
                # Prevent cleanup of history entries before applying design changes
                PentestFinding.history.filter(pk__in=map(lambda f: f.pk, updated_findings)).latest_of_each().update(history_prevent_cleanup=True)
            bulk_update_with_history(PentestFinding, objs=filter(lambda f: f.has_changed, updated_findings), fields=['custom_fields'])

    # New project created (but not copied or imported)
    if created and not instance.copy_of and instance.source != SourceEnum.IMPORTED:
        # Create notes from default notes
        notes = [
            ProjectNotebookPage(project=instance, note_id=n['id'], parent_id=n['parent'], **omit_keys(n, ['id', 'parent'])) 
            for n in (instance.project_type.default_notes or [])
        ]
        for note in notes:
            if note.parent_id:
                note.parent = next(filter(lambda n: n.note_id == note.parent_id, notes), None)
        bulk_create_with_history(ProjectNotebookPage, objs=notes)


@receiver(signals.post_save, sender=ProjectType)
@disable_for_loaddata
@history_context(history_change_reason='Field definition changed', history_prevent_cleanup=True)
def project_type_field_definition_changed(sender, instance, *args, **kwargs):
    """
    When report_fields or finding_fields structure changed, update the field structure of all projects that are based on this project_type
    """
    # Check if finding field definition changed
    if (diff := instance.get_field_diff('finding_fields')) and has_field_structure_changed(parse_field_definition(diff[0]), instance.finding_fields_obj):
        # Update structure of all findings of this project_type
        updated_findings = list(PentestFinding.objects.filter(project__project_type=instance).select_related('project__project_type'))
        for finding in updated_findings:
            finding.update_data(ensure_defined_structure(
                value=finding.data_all, 
                definition=instance.finding_fields_obj, 
                handle_undefined=HandleUndefinedFieldsOptions.FILL_DEFAULT,
                include_unknown=True))
        if settings.SIMPLE_HISTORY_ENABLED:
            # Prevent cleanup of history entries before applying design changes
            PentestFinding.history.filter(pk__in=map(lambda f: f.pk, updated_findings)).latest_of_each().update(history_prevent_cleanup=True)
        bulk_update_with_history(PentestFinding, objs=filter(lambda f: f.has_changed, updated_findings), fields=['custom_fields'])

    # Check if report section definition changed.
    # Report sections are considered as changed if report_fields definitions changed or 
    # sections are created/deleted or fields are moved between sections
    # Changes in the section definition are synced to the ReportSection models of projects.
    report_fields_diff = instance.get_field_diff('report_fields')
    report_fields_changed = report_fields_diff and has_field_structure_changed(parse_field_definition(report_fields_diff[0]), instance.report_fields_obj)
    report_sections_diff = instance.get_field_diff('report_sections')
    report_sections_prev = set([(s['id'], tuple(sorted(s['fields']))) for s in report_sections_diff[0]]) if report_sections_diff else set()
    report_sections_curr = set([(s['id'], tuple(sorted(s['fields']))) for s in report_sections_diff[1]]) if report_sections_diff else set()
    report_sections_changed = report_sections_diff and (report_sections_prev != report_sections_curr)
    if report_fields_changed or report_sections_changed:
        projects = list(PentestProject.objects.filter(project_type=instance).select_related('project_type').prefetch_related('sections'))
        update_project_report_sections_structure(projects=projects, project_type=instance)


@receiver(pre_create_historical_record)
@disable_for_loaddata
def history_set_details(instance, history_instance, *args, **kwargs):
    history_instance.history_prevent_cleanup = getattr(history_instance, '_history_prevent_cleanup', 
                                                       getattr(HistoricalRecords.context, 'history_prevent_cleanup', False))
    history_instance.history_date = getattr(instance, '_history_date', None) or \
        getattr(HistoricalRecords.context, 'history_date', None) or \
        timezone.now()
    history_instance.history_change_reason = getattr(instance, '_history_change_reason', 
                                                     getattr(HistoricalRecords.context, 'history_change_reason', None))
    if history_type := getattr(instance, '_history_type', None):
        history_instance.history_type = history_type
    if history_instance.history_type in ['+', '-']:
        history_instance.history_prevent_cleanup = True

    if not history_instance.history_title:
        if isinstance(instance, PentestProject):
            history_instance.history_title = instance.name
        elif isinstance(instance, ReportSection):
            history_instance.history_title = instance.section_label
        elif isinstance(instance, PentestFinding):
            history_instance.history_title = instance.data.get('title')
        elif isinstance(instance, ProjectNotebookPage):
            history_instance.history_title = instance.title
        elif isinstance(instance, ProjectMemberInfo):
            history_instance.history_title = instance.user.username
        elif isinstance(instance, ProjectType):
            history_instance.history_title = instance.name
        elif isinstance(instance, FindingTemplateTranslation):
            history_instance.history_title = instance.get_language_display()
        elif isinstance(instance, (UploadedImage, UploadedProjectFile, UploadedAsset, UploadedTemplateImage)):
            history_instance.history_title = instance.name

    # Model-specific change_reason
    if history_instance.history_type == '+' and isinstance(instance, ProjectMemberInfo):
        history_instance.history_change_reason = f'Added member @{instance.user.username}'
    elif history_instance.history_type == '-' and isinstance(instance, ProjectMemberInfo):
        history_instance.history_change_reason = f'Removed member @{instance.user.username}'
    elif not history_instance.history_change_reason:
        if history_instance.history_type == '~':
            if isinstance(instance, FindingTemplateTranslation):
                if 'language' in instance.changed_fields:
                    history_instance.history_change_reason = f'Language changed to {instance.get_language_display()}'
                elif 'status' in instance.changed_fields:
                    history_instance.history_change_reason = f'Status changed to {instance.get_status_display()}'
            elif isinstance(instance, FindingTemplate):
                if 'main_translation_id' in instance.changed_fields:
                    history_instance.history_change_reason = f'Main translation changed to {instance.main_translation.get_language_display()}'
            elif isinstance(instance, (PentestFinding, ReportSection, ProjectNotebookPage)):
                if 'status' in instance.changed_fields:
                    history_instance.history_change_reason = f'Status changed to {instance.get_status_display()}'
                elif 'assignee_id' in instance.changed_fields:
                    if instance.assignee:
                        history_instance.history_change_reason = f'Assignee changed to @{instance.assignee.username}'
                    else:
                        history_instance.history_change_reason = 'Unassigned'
            elif isinstance(instance, ProjectMemberInfo):
                if 'roles' in instance.changed_fields:
                    history_instance.history_change_reason = f'Roles of @{instance.user.username} changed'
            elif isinstance(instance, PentestProject):
                if 'project_type_id' in instance.changed_fields:
                    history_instance.history_change_reason = 'Design changed'
                elif 'language' in instance.changed_fields:
                    history_instance.history_change_reason = f'Language changed to {instance.get_language_display()}'
            elif isinstance(instance, ProjectType):
                if set(instance.changed_fields).intersection(['report_fields', 'report_sections', 'finding_fields', 'finding_field_order', 'finding_ordering']):
                    history_instance.history_change_reason = 'Field definition changed'
                elif 'language' in instance.changed_fields:
                    history_instance.history_change_reason = f'Language changed to {instance.get_language_display()}'
                elif 'status' in instance.changed_fields:
                    history_instance.history_change_reason = f'Status changed to {instance.get_status_display()}'
            
    if history_instance.history_change_reason:
        history_instance.history_prevent_cleanup = True


@receiver(signals.post_delete, sender=PentestProject)
@receiver(signals.post_delete, sender=ProjectType)
@receiver(signals.post_delete, sender=FindingTemplate)
def delete_history(sender, instance, *args, **kwargs):
    # On delete of main models: cascade delete all related histories
    if sender == PentestProject:
        instance.history.all().delete()
        PentestFinding.history.filter(project_id=instance.id).delete()
        ReportSection.history.filter(project_id=instance.id).delete()
        ProjectNotebookPage.history.filter(project_id=instance.id).delete()
        UploadedProjectFile.history.filter(linked_object_id=instance.id).delete()
        UploadedImage.history.filter(linked_object_id=instance.id).delete()
    elif sender == ProjectType:
        instance.history.all().delete()
        UploadedAsset.history.filter(linked_object_id=instance.id).delete()
    elif sender == FindingTemplate:
        instance.history.all().delete()
        FindingTemplateTranslation.history.filter(template_id=instance.id).delete()
        UploadedTemplateImage.history.filter(linked_object_id=instance.id).delete()


@receiver(signals.post_delete, sender=UploadedAsset)
@receiver(signals.post_delete, sender=UploadedAsset.history.model)
@receiver(signals.post_delete, sender=UploadedImage)
@receiver(signals.post_delete, sender=UploadedImage.history.model)
@receiver(signals.post_delete, sender=UploadedProjectFile)
@receiver(signals.post_delete, sender=UploadedProjectFile.history.model)
@receiver(signals.post_delete, sender=UploadedTemplateImage)
@receiver(signals.post_delete, sender=UploadedTemplateImage.history.model)
@receiver(signals.post_delete, sender=UploadedUserNotebookImage)
@receiver(signals.post_delete, sender=UploadedUserNotebookFile)
@receiver(signals.post_delete, sender=ArchivedProject)
def uploaded_file_deleted(sender, instance, *args, **kwargs):
    if not instance.file:
        return
    
    storage = sender.instance_type.file.field.storage if hasattr(sender, 'instance_type') else sender.file.field.storage

    # Delete file when instance is deleted from DB and file on filesystem is no loger referenced
    models = [
        UploadedAsset,
        UploadedImage,
        UploadedProjectFile,
        UploadedTemplateImage,
        UploadedUserNotebookImage,
        UploadedUserNotebookFile,
        ArchivedProject,
    ]
    qs = UploadedImage.objects.none()
    for m in models:
        if m.file.field.storage == storage:
            qs = qs.union(m.objects.filter(file=instance.file))
            if hasattr(m, 'history'):
                qs = qs.union(m.history.filter(file=instance.file))

    is_file_referenced = qs.exists()
    if not is_file_referenced:
        try:
            if isinstance(instance.file, str):
                storage.delete(instance.file)
            else:
                instance.file.delete(save=False)
        except (FileNotFoundError, OSError):
            # Ignore file not found. We would have deleted it anyway
            pass



@receiver(signals.post_save, sender=ProjectNotebookPage)
def collab_created(sender, instance, created, *args, **kwargs):
    from reportcreator_api.pentests.consumers import send_collab_event_project_notes
    from reportcreator_api.pentests.serializers import ProjectNotebookPageSerializer, ProjectNotebookPageSortListSerializer

    if getattr(collab_context_store, 'prevent_events', False):
        return

    if created:
        # Send create signal
        send_collab_event_project_notes(OperationalTransformationEvent.objects.create(
            related_id=instance.project_id,
            type=OperationalTransformationEventType.CREATE,
            path=f'notes.{instance.note_id}',
            created=instance.created,
            version=instance.created.timestamp(),
            data={
                'value': ProjectNotebookPageSerializer(instance).data
            }
        ))
        # Send sort signal because creating a note in the middle of the list changes the order of all following notes
        sorted_instances = instance.project.notes.select_related('parent').all()
        ProjectNotebookPageSortListSerializer(sorted_instances, context={'project': instance.project}) \
            .send_collab_signal(sorted_instances)
    elif update_keys := set(instance.changed_fields).intersection({'title', 'text', 'checked', 'icon_emoji'}):
        # TODO: do not send update if source is collab; maybe similar to history context (from asgiref.local import Local)
        for k in update_keys:
            send_collab_event_project_notes(OperationalTransformationEvent.objects.create(
                related_id=instance.project_id,
                type=OperationalTransformationEventType.UPDATE_KEY,
                path=f'notes.{instance.note_id}.{k}',
                created=instance.updated,
                version=instance.updated.timestamp(),
                data={
                    'value': getattr(instance, k)
                }
            ))


@receiver(signals.post_delete, sender=ProjectNotebookPage)
def collab_deleted(sender, instance, *args, **kwargs):
    from reportcreator_api.pentests.consumers import send_collab_event_project_notes
    
    if getattr(collab_context_store, 'prevent_events', False):
        return
    
    send_collab_event_project_notes(OperationalTransformationEvent.objects.create(
        related_id=instance.project_id,
        type=OperationalTransformationEventType.DELETE,
        path=f'notes.{instance.note_id}',
        created=timezone.now(),
        version=timezone.now().timestamp(),
        data={}
    ))

